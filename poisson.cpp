/*
 * solve Poisson equation $-\Delta u = f$ with spectral element method
 *     the domain is generated by ./mesh_generate/main, Dirichlet boundary condition
 * evaluate the l2 error for both interpolation and numerical solution
 * output SEM solution, which can be converted to an opendx result via ./visualize/main
 * this simulation is based on DealII and AFEPack
 *
 * argv[1]: file name of mesh
 * argv[2]: truncation order
 * argv[3]: file name of output sem solution
 */

#include <iostream>
#include <fstream>
#include <iomanip>

#include <AFEPack/Geometry.h>
#include <AFEPack/TemplateElement.h>
#include <AFEPack/FEMSpace.h>

#include <lac/solver_cg.h>
#include <lac/precondition.h>

#define PI (4.0*atan(1.0))
#define DIM 3

double u(const double * p)
{// $-\Delta u = f$, exact solution
    double x = p[0], y = p[1], z = p[2];
    return sin(PI*x) * cos(5*PI*y) * exp(z);
}

double f(const double * p)
{// $-\Delta u = f$, right-hand-side
    double x = p[0], y = p[1], z = p[2];
    return 26*PI*PI * u(p) - u(p);
}

int calc_binomial_coefficient(int n, int m)
{// calculate binomial coefficient $\binom{n}{m}$
    int val = 1;
    if (n > 0 && n >= m){
        if (n-m < m) m = n-m;
        for (int i = 0; i < m; ++i){val *= (n-i); val /= (i+1);}}
    return val;
}

AFEPack::Point<DIM> calc_cross_product(AFEPack::Point<DIM> p1, AFEPack::Point<DIM> p2)
{// calculate the cross product between 0p1 and 0p2
    AFEPack::Point<DIM> ans;
    ans[0] =  p1[1] * p2[2] - p1[2] * p2[1];
    ans[1] = -p1[0] * p2[2] + p1[2] * p2[0];
    ans[2] =  p1[0] * p2[1] - p1[1] * p2[0];
    return ans;
}

double calc_inner_product(AFEPack::Point<DIM> p1, AFEPack::Point<DIM> p2)
{// calculate the inner product between two vectors, whose enties are given by points p1 and p2
    return p1[0] * p2[0] + p1[1] * p2[1] + p1[2] * p2[2];
}

double calc_delta(int i, int j)
{// calculate the delta function $\delta_{ij}$
    if (i == j) return 1;
    return 0;
}

struct Multiindex
{// DIM dimensional multiindex
    int index[DIM];
    bool operator <= (const Multiindex& multiindex){ // overload relation <= for multiindex
        for (int i = 0; i < DIM; ++i) if (this->index[i] > multiindex.index[i]) return false;
        return true;
    }
    bool operator == (const Multiindex& multiindex){ // overload relation <= for multiindex
        for (int i = 0; i < DIM; ++i) if (this->index[i] != multiindex.index[i]) return false;
        return true;
    }
    bool operator != (const Multiindex& multiindex){ // overload relation != for multiindex
        for (int i = 0; i < DIM; ++i) if (this->index[i] != multiindex.index[i]) return true;
        return false;}
    void operator = (const Multiindex& multiindex){ // overload operation = for multiindex
        for (int i = 0; i < DIM; ++i) this->index[i] = multiindex.index[i];}
    Multiindex operator + (const Multiindex& multiindex){ // overload operation + for multiindex
        Multiindex ans;
        for (int i = 0; i < DIM; ++i) ans.index[i] = this->index[i] + multiindex.index[i];
        return ans;}
    Multiindex operator - (const Multiindex& multiindex){ // overload operation + for multiindex
        Multiindex ans;
        for (int i = 0; i < DIM; ++i) ans.index[i] = this->index[i] - multiindex.index[i];
        return ans;}
    Multiindex operator * (int n){ // overload operation * for multiindex
        Multiindex ans;
        for (int i = 0; i < DIM; ++i) ans.index[i] = this->index[i] * n;
        return ans;}
    int sum(){ // summation of all components
        int ans;
        for (int i = 0; i < DIM; ++i) ans += this->index[i];
        return ans;}
    int n_nonzero(){ // number of nonzero components
        int ans = 0;
        for (int i = 0; i < DIM; ++i) if (this->index[i] != 0) ans++;
        return ans;}
};

static Multiindex Unitary_Multiindex[DIM];

int calc_binomial_coefficient_multiindex(Multiindex alpha, Multiindex beta)
{// calculate binomial coefficient for multiindex $\binom{\alpha}{\beta}$
    int val = 1;
    for (int ind = 0; ind < DIM; ++ind) // for $\beta$ or $\alpha-\beta$ with negative component, return 0
        if (beta.index[ind] < 0 || beta.index[ind] > alpha.index[ind])
            return 0;
    for (int ind = 0; ind < DIM; ++ind)
        val *= calc_binomial_coefficient(alpha.index[ind], beta.index[ind]);
    return val;
}

class Correspondence
{/* correpondence between
  *   multiindex and number of multiindex in lexicographical order
  */
    int M; // truncation order
    int number_index; // number of multiindex $|\alpha|\leq M$
    Multiindex *number_to_index; // number_to_index[i] = i-th multiindex in lexicographical order
    int **number_multiindex; /* number_multiindex[i=0:DIM-1]: number of multiindices with $(i+1)$ components and summation less than some number
                              *     number_multiindex[i=0:DIM-1][j=0:M]: number of multiindices $\beta=(\beta_k)_{k=0}^i\leq j$
                              */
public:
    // Multiindex unitary_multiindex[DIM];
    void init(int order_truncate); // initialize with truncation order
    int index2number(Multiindex multiindex); // return the number of given multiindex in lexicographical order
    Multiindex number2index(int number_index){ // return the (number_index)-th multiindex
        return number_to_index[number_index];}
    int n_index(){ // return number of multiindex $|\alpha|\leq M$, where M is truncation order
        return number_multiindex[DIM-1][M];}
    int n_index_begin(int order){ // return begin number of multiindex for $|\alpha|=order$ in lexicographical order
        if (order == 0) return 0;
        else return number_multiindex[DIM-1][order-1];}
    int n_index_end(int order){ // return begin number of multiindex for $|\alpha|=order+1$ in lexicographical order, which is also the number of multiindex $|\alpha|\leq order$
        return number_multiindex[DIM-1][order];}
} correspondence;

void Correspondence::init(int order_truncate)
{// initialize correspondence with given truncation order
    // unitary multiindex
    for (int i = 0; i < DIM; ++i){
        for (int j = 0; j < DIM; ++j)
            Unitary_Multiindex[i].index[j] = 0;
        Unitary_Multiindex[i].index[i] = 1;
    }
    M = order_truncate;
    // calculate number_multiindex
    number_multiindex = new int* [DIM]; // number_multiindex[i=0:DIM-1]: number of multiindices with $(i+1)$ components and summation less than some number
    for (int i = 0; i < DIM; ++i)
        number_multiindex[i] = new int [M+1];
    for (int i = 0; i < DIM; ++i) // number_multiindex[i=0:DIM-1][j=0:M]: number of multiindices $\beta=(\beta_k)_{k=0}^i\leq j$
        for (int j = 0; j <= M; ++j){
            number_multiindex[i][j] = calc_binomial_coefficient(i+j, i);
            if (j > 0) number_multiindex[i][j] += number_multiindex[i][j-1];
        }
    number_index = number_multiindex[DIM-1][M];
    // calculate i-th multiindex
    number_to_index = new Multiindex [number_index];
    for (int i = 0; i < number_index; ++i){
        int tmp_i = i+1;
        int sum = M;
        for (int j = 0; j < DIM; ++j){ // traverse summation of multiindex $|(\alpha_k)_{k=j}^{DIM-1}|$
            int k = sum - 1;
            for (; k >= 0; k -= 1)
                if (number_multiindex[DIM-1-j][k] < tmp_i)
                    break;
            if (j > 0) number_to_index[i].index[j-1] = sum - (k+1); // now step = 1
            sum = k + 1;
            if (k >= 0) tmp_i -= number_multiindex[DIM-1-j][k];
        }
        number_to_index[i].index[DIM-1] = sum;
    }
}

int Correspondence::index2number(Multiindex multiindex)
{// calculate the number of given multiindex
    int num = 0; // default for zero multiindex
    for (int i = 0; i < DIM; ++i){
        int sum = 0; // summation of last several components of multiindex $|(\alpha_k)_{k=i}^{DIM-1}|$
        for (int j = i; j < DIM; ++j)
            sum += multiindex.index[j];
        if (sum == 0) break;
        else num += number_multiindex[DIM-1-i][sum-1];
    }
    
    return num;
}


double calc_generalized_jacobi_polynomial(int alpha, int beta, int k, double x)
{// calculate k-th generalized jocobi polynomial with index (alpha, beta) at point x, where $alpha, beta >= -1$
    if (k == 0) return 1.0;
    if (alpha + beta == -2)
        if (k == 1) return x;
        else return 0.25 * (x-1) * (x+1) * calc_generalized_jacobi_polynomial(1, 1, k-2, x);
    if (alpha == -1)
        return (k+beta) * (x-1) / (k*2) * calc_generalized_jacobi_polynomial(1, beta, k-1, x);
    if (beta == -1)
        return (k+alpha) * (x+1) / (k*2) * calc_generalized_jacobi_polynomial(alpha, 1, k-1, x);
    double ans = 0.0, tmp_power = 1.0;
    for (int j = 0; j <= k; ++j){
        double factor = 1.0;
        for (int i = 0; i < k-j; ++i)
            factor *= (alpha+j+1 + i) / (i+1);
        for (int i = 0; i < j; ++i)
            factor *= (k+alpha+beta+1 + i) / (i+1);
        ans += factor * tmp_power;
        tmp_power *= (x - 1) * 0.5;
    }
    return ans;
}

double calc_coefficient_a(int alpha, int beta, int ind, int k)
{// calculate coefficient $a_{ind, k}^{alpha, beta}$
    if (k < 0) return 0;
    switch (ind){
    case 1:
        if (alpha == -1 && beta == -1)
            switch (k){
            case 0: return 1;
            case 1: return 4;
            case 2: return 0.5;
            }
        if (k == 0 && alpha + beta != -2)
            return 2.0 / (alpha + beta + 2);
        return 2.0 * (k+1) * (k+alpha+beta+1) / ((2*k+alpha+beta+1) * (2*k+alpha+beta+2));
    case 2:
        if (0 <= k && k <= 2 && alpha == -1 && beta == -1) return 0;
        if (k == 0 && alpha + beta != -2)
            return (beta - alpha) / (alpha + beta + 2.0);
        return (pow(beta,2)-pow(alpha,2)) / ((2*k+alpha+beta) * (2*k+alpha+beta+2.0));
    case 3:
        if (alpha == -1 && beta == -1){
            if (k == 0) return 0;
            if (k == 1) return 1;
            if (k == 2) return 0;
        }
        if (k == 0 && alpha+beta != -2)
            return 0;
        return 2.0 * (k+alpha) * (k+beta) / ((2*k+alpha+beta) * (2*k+alpha+beta+1));
    }
}

double calc_coefficient_b(int alpha, int beta, int ind, int k)
{// calculate coefficient $b_{ind, k}^{alpha, beta}$
    if (k < 0) return 0;
    switch (ind){
    case 1:
        if (k == 0 && alpha >= -1 && beta >= -1) return 1;
        if (k == 1 && alpha == -1 && beta == -1) return 2;
        return (k+alpha+beta+1.0) / (2*k+alpha+beta+1);
    case 2:
        if (k == 0 && alpha >= -1 && beta >= -1) return 0;
        if (k == 1 && alpha == -1 && beta == -1) return -1;
        return -(k+beta) / (2*k+alpha+beta+1.0);
        break;
    }
}

double calc_coefficient_c(int alpha, int beta, int ind, int k)
{// calculate coefficient $c_{ind, k}^{alpha, beta}$
    switch (ind){
    case 1: return calc_coefficient_b(alpha, beta, 1, k) * calc_coefficient_b(alpha+1, beta, 1, k);
    case 2: return calc_coefficient_b(alpha, beta, 1, k) * calc_coefficient_b(alpha+1, beta, 2, k) +
                   calc_coefficient_b(alpha, beta, 2, k) * calc_coefficient_b(alpha+1, beta, 1, k-1);
    case 3: return calc_coefficient_b(alpha, beta, 2, k) * calc_coefficient_b(alpha+1, beta, 2, k-1);
        break;
    }
}

double calc_coefficient_d(int alpha, int beta, int k)
{// calculate coefficient $d_k^{alpha, beta}$
    if (k <= 0) return 0;
    if (k == 1 && alpha == -1 && beta == -1) return 1;
    return (k+alpha+beta+1.0) / 2;
}

double calc_coefficient_e(int alpha, int beta, int ind, int k)
{// calculate coefficient $e_{ind, k}^{alpha, beta}$
    if (k < 0) return 0;
    switch (ind){
    case 1:
        if (k == 0 && alpha == -1 && beta == -1) return 0.5;
        if (k == 1 && alpha == -1 && beta == -1) return 0;
        return (k+alpha+1.0) / (2*k+alpha+beta+2);
    case 2:
        if (k == 0 && alpha == -1 && beta == -1) return -0.5;
        if (k == 1 && alpha == -1 && beta == -1) return -1;
        return -(k+1.0) / (2*k+alpha+beta+2);
        break;
    }
}

double calc_coefficient_g(int alpha, int beta, int ind, int k)
{// calculate coefficient $g_{ind, k}^{alpha, beta}$
    switch (ind){
    case 1: return calc_coefficient_e(alpha+1, beta, 2, k) * calc_coefficient_e(alpha, beta, 2, k+1);
    case 2: return calc_coefficient_e(alpha+1, beta, 1, k) * calc_coefficient_e(alpha, beta, 2, k) +
                   calc_coefficient_e(alpha+1, beta, 2, k) * calc_coefficient_e(alpha, beta, 1, k+1);
    case 3: return calc_coefficient_e(alpha+1, beta, 1, k) * calc_coefficient_e(alpha, beta, 1, k);
        break;
    }
}

double calc_coefficient_rho(Multiindex index)
{// calculate coefficient $\rho_{index}^{-\mathds{1}}$
    int l1 = index.index[0], l2 = index.index[1];
    return 2 * calc_coefficient_d(-1, -1, l1) * calc_coefficient_e(-1, 0, 1, l1-1)
        - l1 * calc_coefficient_b(-1, -1, 2, l1);
}

double calc_coefficient_kappa(Multiindex index)
{// calculate coefficient $\kappa_{index}^{-\mathds{1}}$
    int l1 = index.index[0], l2 = index.index[1];
    return l1 * calc_coefficient_b(-1, -1, 2, l1)
        - 2 * calc_coefficient_d(-1, -1, l1) * calc_coefficient_e(-1, 0, 1, l1-1);
}

double calc_coefficient_theta(Multiindex index)
{// calculate coefficient $\theta_{index}^{-\mathds{1}}$
    int l1 = index.index[0], l2 = index.index[1];
    return 2 * calc_coefficient_d(2*l1-1, -1, l2) * calc_coefficient_e(-1, 2*l1, 1, l2-1)
        - l2 * calc_coefficient_b(2*l1-1, -1, 2, l2);
}

double calc_coefficient_D(int ind_derivative, int ind_variation, Multiindex index)
{// calculate coefficient for the derivative of generalized jacobi polynomial
    int l1 = index.index[0], l2 = index.index[1], l3 = index.index[2];
    int aph2 = 2 * l1, aph3 = 2 * l1 + 2 * l2;
    switch (ind_derivative){
    case 0: // $\partial x1$,               or multiindex (2, 0, 0)
        return 2 * calc_coefficient_d(-1, -1, l1);
    case 1: // $\partial x2 - \partial x1$, or multiindex (1, 1, 0)
        switch (ind_variation){
        case 0: // $D^{21}_0 =  D^{2}_0$
            return 2 * calc_coefficient_d(aph2-1, -1, l2) * calc_coefficient_b(-1, -1, 1, l1);
        case 1: // $D^{21}_1 = -D^{2}_1$
            return -((2*calc_coefficient_d(-1,-1,l1)*calc_coefficient_e(-1,0,1,l1-1) - l1*calc_coefficient_b(-1,-1,2,l1)) * calc_coefficient_b(aph2-1,-1,1,l2)
                        + 2*calc_coefficient_d(aph2-1,-1,l2)*calc_coefficient_b(-1,-1,2,l1)*calc_coefficient_e(aph2-1,0,2,l2-1)) / calc_coefficient_b(aph2-2,0,1,l2);
        }
    case 2: // $\partial x1 - \partial x3$, or multiindex (1, 0, 1)
        switch (ind_variation){
        case 0: // $D^{31}_{0,0} = -D^3_{0,0}$
            return -2 * calc_coefficient_d(aph3-1,-1,l3) * calc_coefficient_b(-1,-1,1,l1) * calc_coefficient_b(aph2-1,-1,1,l2);
        case 1: // $D^{31}_{1,0} =  D^3_{1,0}$
            return 2 * calc_coefficient_d(aph3-1,-1,l3) * calc_coefficient_b(-1,-1,2,l1) * calc_coefficient_e(aph2-2,-1,2,l2);
        case 2: // $D^{31}_{0,1} = -D^3_{0,1}$
            return -(calc_coefficient_b(-1,-1,1,l1)*calc_coefficient_theta(index)*calc_coefficient_b(aph3-1,-1,1,l3)
                        + 2*calc_coefficient_d(aph3-1,-1,l3)*calc_coefficient_b(-1,-1,1,l1)*calc_coefficient_b(aph2-1,-1,2,l2)
                     *calc_coefficient_e(aph3-1,0,2,l3-1)) / calc_coefficient_b(aph3-2,0,1,l3);
        case 3:
            return ((calc_coefficient_b(-1,-1,2,l1)*calc_coefficient_e(aph2-1,-1,2,l2-1)*calc_coefficient_theta(index) - calc_coefficient_kappa(index))
                        * calc_coefficient_b(aph3-1,-1,1,l3) + 2*calc_coefficient_b(aph2-2,-1,1,l2)*calc_coefficient_d(aph3-1,-1,l3)
                        *calc_coefficient_b(-1,-1,2,l1)*calc_coefficient_e(aph2-2,-1,1,l2)*calc_coefficient_e(aph3-1,0,2,l3-1))
                / (calc_coefficient_b(aph2-2,-1,1,l2)*calc_coefficient_b(aph3-2,0,1,l3));
        }
    case 3: // $\partial x2$,               or multiindex (0, 2, 0)
        switch (ind_variation){
        case 0: return 2 * calc_coefficient_d(aph2-1, -1, l2) * calc_coefficient_b(-1, -1, 1, l1);
        case 1: return ((2*calc_coefficient_d(-1,-1,l1)*calc_coefficient_e(-1,0,1,l1-1) - l1*calc_coefficient_b(-1,-1,2,l1)) * calc_coefficient_b(aph2-1,-1,1,l2)
                        + 2*calc_coefficient_d(aph2-1,-1,l2)*calc_coefficient_b(-1,-1,2,l1)*calc_coefficient_e(aph2-1,0,2,l2-1)) / calc_coefficient_b(aph2-2,0,1,l2);
        }
    case 4: // $\partial x3 - \partial x2$, or multiindex (0, 1, 1)
        switch (ind_variation){
        case 0: return  2 * calc_coefficient_d(aph3-1,-1,l3) * calc_coefficient_b(aph2-1,-1,1,l2);
        case 1:
            return ((l2*calc_coefficient_b(-1,aph2-1,2,l2) - 2*calc_coefficient_d(aph2-1,-1,l2)*calc_coefficient_e(aph2-1,0,1,l2-1))
                        * calc_coefficient_b(aph3-1,-1,1,l3) - 2*calc_coefficient_d(aph3-1,-1,l3)*calc_coefficient_b(-1,aph2-1,2,l2)
                        *calc_coefficient_e(aph3-1,0,2,l3-1)) / calc_coefficient_b(aph3-2,0,1,l3);
        }
    case 5: // $\partial x3$,               or multiindex (0, 0, 2)
        switch (ind_variation){
        case 0: return 2 * calc_coefficient_d(aph3-1,-1,l3) * calc_coefficient_b(-1,-1,1,l1) * calc_coefficient_b(aph2-1,-1,1,l2);
        case 1: return 2 * calc_coefficient_d(aph3-1,-1,l3) * calc_coefficient_b(-1,-1,2,l1) * calc_coefficient_e(aph2-2,-1,2,l2);
        case 2:
            return (calc_coefficient_b(-1,-1,1,l1)*calc_coefficient_theta(index)*calc_coefficient_b(aph3-1,-1,1,l3)
                        + 2*calc_coefficient_d(aph3-1,-1,l3)*calc_coefficient_b(-1,-1,1,l1)*calc_coefficient_b(aph2-1,-1,2,l2)
                        *calc_coefficient_e(aph3-1,0,2,l3-1)) / calc_coefficient_b(aph3-2,0,1,l3);
        case 3:
            return ((calc_coefficient_rho(index) + calc_coefficient_b(-1,-1,2,l1)*calc_coefficient_e(aph2-1,-1,2,l2-1)*calc_coefficient_theta(index))
                        * calc_coefficient_b(aph3-1,-1,1,l3) + 2*calc_coefficient_b(aph2-2,-1,1,l2)*calc_coefficient_d(aph3-1,-1,l3)
                        *calc_coefficient_b(-1,-1,2,l1)*calc_coefficient_e(aph2-2,-1,1,l2)
                        *calc_coefficient_e(aph3-1,0,2,l3-1)) / (calc_coefficient_b(aph2-2,-1,1,l2)*calc_coefficient_b(aph3-2,0,1,l3));
        }
    }
}

int main(int argc, char * argv[])
{
    // read mesh from argv[1]
    HGeometryTree<DIM> h_tree;
    h_tree.readMesh(argv[1]);
    IrregularMesh<DIM> *irregular_mesh;
    irregular_mesh = new IrregularMesh<DIM>;
    irregular_mesh->reinit(h_tree);
    irregular_mesh->semiregularize();
    irregular_mesh->regularize(false);
    RegularMesh<DIM> &mesh = irregular_mesh->regularMesh();
    int n_geometry[DIM+1];
    for (int ind = 0; ind <= DIM; ++ind)
        n_geometry[ind] = mesh.n_geometry(ind);
    // assign reference point for each geometry
    std::vector<std::vector<AFEPack::Point<DIM> > > point_ref_mesh; // [i = 0:3], barycenter of i dimensional geometry
    point_ref_mesh.resize(4);
    for (int ind = 0; ind <= DIM; ++ind){
        point_ref_mesh[ind].resize(mesh.n_geometry(ind));
        for (int i = 0; i < mesh.n_geometry(ind); ++i){
            AFEPack::Point<DIM> point_tmp = mesh.point(mesh.geometry(ind, i).vertex(0));
            for (int indt = 1; indt <= ind; ++indt)
                point_tmp += mesh.point(mesh.geometry(ind, i).vertex(indt));
            point_tmp /= (ind + 1);
            point_ref_mesh[ind][i] = point_tmp;
        }
    }

    
    // generate finite element space following AFEPack
    TemplateGeometry<DIM> template_geometry;
    CoordTransform<DIM, DIM> coord_transform;
    TemplateDOF<DIM> template_dof;
    BasisFunctionAdmin<double, DIM, DIM> basis_function;
    template_geometry.readData("tetrahedron.tmp_geo");
    coord_transform.readData("tetrahedron.crd_trs");
    template_dof.reinit(template_geometry);
    template_dof.readData("tetrahedron.2.tmp_dof");
    basis_function.reinit(template_dof);
    basis_function.readData("tetrahedron.2.bas_fun");
    std::vector<TemplateElement<double, DIM, DIM> > template_element(1);
    template_element[0].reinit(template_geometry,
                               template_dof,
                               coord_transform,
                               basis_function);
    FEMSpace<double, DIM> fem_space(mesh, template_element);
    int n_element = mesh.n_geometry(DIM);
    fem_space.element().resize(n_element);
    for (int i = 0; i < n_element; ++i)
        fem_space.element(i).reinit(fem_space, i, 0);
    fem_space.buildElement();
    fem_space.buildDof();
    fem_space.buildDofBoundaryMark();
    FEMSpace<double, DIM>::ElementIterator the_element = fem_space.beginElement();
    FEMSpace<double, DIM>::ElementIterator end_element = fem_space.endElement();
    
    // initialize, read truncation polynomial order from argv[2]
    int n_dof = fem_space.n_dof();
    int n_fem_element = fem_space.n_element();
    int M = atoi(argv[2]); // truncation order
    correspondence.init(M);
    int n_index = correspondence.n_index();
    std::cout << "Initialize correspondence of multiindex with truncation order " << M << ", find " << n_index << " multiindices\n";
    std::vector<int> n_dof_geometry(DIM+1); // number of dof location on each dimensional geoemtry
    for (int ind = 0; ind <= DIM; ++ind) // number of dof on ind dimensional geometry
        n_dof_geometry[ind] = calc_binomial_coefficient(M-1, ind);
    int n_dof_total = 0; // number of total degree of freedom
    for (int ind = 0; ind <= DIM; ++ind)
        n_dof_total += n_geometry[ind] * n_dof_geometry[ind]; // sum up all dof on each dimensional geometry
    for (int ind = 0; ind <= DIM; ++ind)
        std::cout << "n_dof_geometry[" << ind << "] = " << n_dof_geometry[ind] << ",\t";
    std::cout << '\n';
    std::cout << "the total dof is " << n_dof_total << '\n';

    
    // read quadrature info
    int n_quad_accuracy[3] = {38, 20, 20}; // [i]: accuracy of i dimensional quadrature rule
    int n_q_point[3] = {20, 88, 448}; // [i]: number of quadrature point in i dimensional rule
    std::vector<AFEPack::Point<DIM> > QPoint; // 3-d quadrature point
    std::vector<std::vector<std::vector<double> > > QPoint_Barycenter; // 1 & 2-d quadrature point in barycenter coordinate
    QPoint.resize(n_q_point[DIM-1]);
    QPoint_Barycenter.resize(DIM-1);
    for (int ind = 0; ind < DIM-1; ++ind){
        QPoint_Barycenter[ind].resize(n_q_point[ind]);
        for (int i = 0; i < n_q_point[ind]; ++i)
            QPoint_Barycenter[ind][i].resize(ind+2);
    }
    std::vector<std::vector<double> > Weight;
    std::ifstream inputfile;
    Weight.resize(DIM);
    for (int ind = 0; ind < DIM; ++ind)
        Weight[ind].resize(n_q_point[ind]);
    for (int ind = 0; ind < DIM; ++ind){
        switch (ind){
        case 0: inputfile.open("./quad_info/quad_info_1d_p38.dat");
            break;
        case 1: inputfile.open("./quad_info/quad_info_2d_p20.dat");
            break;
        case 2: inputfile.open("./quad_info/nme6313-sup-0001-supinfo/NME_6313_cubature_tetra_p20_n448.dat");
            break;
        }
        for (int p = 0; p < n_q_point[ind]; ++p){
            for (int indt = 0; indt <= ind; ++indt)
                if (ind == DIM-1)
                    inputfile >> QPoint[p][indt];
                else
                    inputfile >> QPoint_Barycenter[ind][p][indt];
            if (ind == 0) // modify coordinate to be barycenter one
                QPoint_Barycenter[ind][p][0] = (QPoint_Barycenter[ind][p][0] + 1) * 0.5;
            if (ind < DIM-1){ // calculate the barycenter coordinate of the last point
                QPoint_Barycenter[ind][p][ind+1] = 1.0;
                for (int indt = 0; indt <= ind; ++indt)
                    QPoint_Barycenter[ind][p][ind+1] -= QPoint_Barycenter[ind][p][indt];
            }
            inputfile >> Weight[ind][p];
        }
        std::cout << "Read " << ind+1 << "d quadrature info with accuracy " << n_quad_accuracy[ind] << ", find " << n_q_point[ind] << " points and weights\n";
        inputfile.close();
    }    
    // calculate the value of basis function at each quadrature point
    std::vector<std::vector<std::vector<double> > > basis_value; // [ind = 0:2][p = 0:n_q_point[ind]-1][]: basis_value for ind+1 dimensional quadrature region
    basis_value.resize(DIM);
    for (int ind = 0; ind < DIM; ++ind)
        basis_value[ind].resize(n_q_point[ind]);
    // basis function value at 3-d quadrature points
    for (int p = 0; p < n_q_point[DIM-1]; ++p){
        double x = QPoint[p][0], y = QPoint[p][1], z = QPoint[p][2];
        double xi = 2*x/(1-y-z)-1, eta = 2*y/(1-z)-1, zeta = 2*z-1;
        basis_value[DIM-1][p].resize(n_index);
        // calculate $J_k^{-1,-1}(xi)$ for k = 0: M
        double Jxi[M+1], Jeta[M+1], Jzeta[M+1];
        Jxi[0] = Jeta[0] = Jzeta[0] = 1;
        Jxi[1] = xi; // as J_1^{-1,-1}(xi) = xi
        for (int k = 1; k < M; ++k)
            Jxi[k+1] = ((xi - calc_coefficient_a(-1,-1,2,k)) * Jxi[k] - calc_coefficient_a(-1,-1,3,k) * Jxi[k-1]) / calc_coefficient_a(-1,-1,1,k);
        // traverse first component of multiindex
        for (int l1 = 0; l1 <= M; ++l1){
            int aph2 = 2 * l1 - 1; // alpha for the generalized jacobi polynomial of eta
            // calculate value of generalized jacobi polynomial Jeta
            Jeta[1] = calc_generalized_jacobi_polynomial(aph2, -1, 1, eta);
            for (int k = 1; k < M-l1; ++k)
                Jeta[k+1] = ((eta - calc_coefficient_a(aph2,-1,2,k)) * Jeta[k] - calc_coefficient_a(aph2,-1,3,k) * Jeta[k-1]) / calc_coefficient_a(aph2,-1,1,k);
            // traverse second component
            for (int l2 = 0; l2 <= M-l1; ++l2){
                int aph3 = 2 * l1 + 2 * l2 - 1;
                Jzeta[1] = calc_generalized_jacobi_polynomial(aph3, -1, 1, zeta);
                for (int k = 1; k < M-l1-l2; ++k)
                    Jzeta[k+1] = ((zeta - calc_coefficient_a(aph3,-1,2,k)) * Jzeta[k] - calc_coefficient_a(aph3,-1,3,k) * Jzeta[k-1]) / calc_coefficient_a(aph3,-1,1,k);
                // traverse third component
                for (int l3 = 0; l3 <= M-l1-l2; ++l3){
                    Multiindex index_now = Unitary_Multiindex[0] * l1 + Unitary_Multiindex[1] * l2 + Unitary_Multiindex[2] * l3;
                    basis_value[DIM-1][p][correspondence.index2number(index_now)] = pow(1-y-z,l1)*Jxi[l1] * pow(1-z,l2)*Jeta[l2] * Jzeta[l3];
                }
            }
        }
    }
    for (int p = 0; p < n_q_point[1]; ++p){
        basis_value[1][p].resize(n_dof_geometry[2]);
        double x = QPoint_Barycenter[1][p][0], y = QPoint_Barycenter[1][p][1];
        double xi = 2*x/(1-y)-1, eta = 2*y-1;
        double Jxi[M+1], Jeta[M+1];
        Jxi[0] = Jeta[0] = 1;
        Jxi[1] = xi;
        for (int l = 1; l < M; ++l)
            Jxi[l+1] = ((xi - calc_coefficient_a(-1,-1,2,l))*Jxi[l] - calc_coefficient_a(-1,-1,3,l)*Jxi[l-1]) / calc_coefficient_a(-1,-1,1,l);
        for (int l1 = 2; l1 <= M; ++l1){
            int aph = 2 * l1 - 1;
            Jeta[1] = calc_generalized_jacobi_polynomial(aph, -1, 1, eta);
            for (int l = 1; l < M; ++l)
                Jeta[l+1] = ((eta - calc_coefficient_a(aph,-1,2,l))*Jeta[l] - calc_coefficient_a(aph,-1,3,l)*Jeta[l-1]) / calc_coefficient_a(aph,-1,1,l);
            for (int l2 = 1; l2 <= M-l1; ++l2){
                int ind_index = (1+l1+l2-3) * (l1+l2-3) / 2 + l2 - 1;
                basis_value[1][p][ind_index] = 2 * pow(1-y, l1) * Jxi[l1] * Jeta[l2];
            }
        }
    }
    for (int p = 0; p < n_q_point[0]; ++p){
        basis_value[0][p].resize(n_dof_geometry[1]);
        double xi = QPoint_Barycenter[0][p][0] * 2 - 1;
        double Jxi[M+1];
        Jxi[0] = 1;
        Jxi[1] = xi;
        for (int l = 1; l < M; ++l)
            Jxi[l+1] = ((xi - calc_coefficient_a(-1,-1,2,l))*Jxi[l] - calc_coefficient_a(-1,-1,3,l)*Jxi[l-1]) / calc_coefficient_a(-1,-1,1,l);
        for (int l = 2; l <= M; ++l)
            basis_value[0][p][l-2] = 2 * Jxi[l];
    }
    std::cerr << "calculate function value of generalized jacobi polynomial at quadrature points\n";
    // calculate the value of generalized jacobi polynomial for the interpolation of function
    std::vector<std::vector<std::vector<double > > > basis_value_interp(DIM);
    // additional basis value, [p][l][0]: $(1-y)^l*J_{l-2}^{1,1}(\xi_p)$, [p][l][1]: $J_{l-2}^{1,1}(\eta_p)$
    std::vector<std::vector<std::vector<double> > > basis_value_addition(n_q_point[1]);
    // initialize
    for (int ind = 0; ind < DIM; ++ind){
        basis_value_interp[ind].resize(n_q_point[ind]);
        for (int p = 0; p < n_q_point[ind]; ++p)
            basis_value_interp[ind][p].resize(n_dof_geometry[ind+1]);
    }
    // for the interpolation of the dof on edge
    for (int p = 0; p < n_q_point[0]; ++p){
        double xp = 2 * QPoint_Barycenter[0][p][0] - 1;
        basis_value_interp[0][p][0] = 1;
        basis_value_interp[0][p][1] = calc_generalized_jacobi_polynomial(1, 1, 1, xp);
        for (int l = 1; l < M-2; ++l)
            basis_value_interp[0][p][l+1] = ((xp - calc_coefficient_a(1,1,2,l)) * basis_value_interp[0][p][l]
                                             - calc_coefficient_a(1,1,3,l) * basis_value_interp[0][p][l-1]) / calc_coefficient_a(1,1,1,l);
    }
    // for the interpolation of the dof on face
    for (int p = 0; p < n_q_point[1]; ++p){
        basis_value_addition[p].resize(n_dof_geometry[1]);
        for (int l = 0; l < n_dof_geometry[1]; ++l)
            basis_value_addition[p][l].resize(2);
    }
    for (int p = 0; p < n_q_point[1]; ++p){
        double xp = QPoint_Barycenter[1][p][0], yp = QPoint_Barycenter[1][p][1];
        double xi = 2*xp/(1-yp) - 1, eta = 2*yp - 1;
        double Jxi[M-1], Jeta[M];
        // evaluate basis_value_interp
        Jxi[0] = Jeta[0] = 1;
        Jxi[1] = calc_generalized_jacobi_polynomial(1, 1, 1, xi);
        for (int l = 1; l < M-2; ++l) // evaluate Jxi by recursion relation
            Jxi[l+1] = ((xi - calc_coefficient_a(1,1,2,l)) * Jxi[l] - calc_coefficient_a(1,1,3,l) * Jxi[l-1]) / calc_coefficient_a(1,1,1,l);
        for (int l1 = 2; l1 <= M; ++l1){
            Jeta[1] = calc_generalized_jacobi_polynomial(2*l1-1, 1, 1, eta);
            for (int l2 = 1; l2 < M-l1; ++l2) // evaluate Jeta by recursion relation, Jeta[M-l1] is un-used
                Jeta[l2+1] = ((eta - calc_coefficient_a(2*l1-1,1,2,l2)) * Jeta[l2] - calc_coefficient_a(2*l1-1,1,3,l2) * Jeta[l2-1]) / calc_coefficient_a(2*l1-1,1,1,l2);
            for (int l2 = 1; l2 <= M-l1; ++l2){ // assign basis_value_interp, corresponds to (l1-2, l2-1)
                int ind_index = (1+l1+l2-3) * (l1+l2-3) / 2 + l2-1;
                basis_value_interp[1][p][ind_index] = pow(1-eta, l1-2) * Jxi[l1-2] * Jeta[l2-1];
            }
        }
        // evaluate basis_value_addition, which correspond to $(1-yp)^{l-2}J_{l-2}^{1,1}(xi)$ and $J_{l-2}^{1,1}(eta)$ for l = 2: M
        for (int l = 2; l <= M; ++l)
            basis_value_addition[p][l-2][0] = pow(1-yp, l-2) * Jxi[l-2]; // as Jxi is the same
        Jeta[1] = calc_generalized_jacobi_polynomial(1, 1, 1, eta);
        for (int l = 1; l < M-2; ++l)
            Jeta[l+1] = ((eta - calc_coefficient_a(1,1,2,l)) * Jeta[l] - calc_coefficient_a(1,1,3,l) * Jeta[l-1]) / calc_coefficient_a(1,1,1,l);
        for (int l = 2; l <= M; ++l)
            basis_value_addition[p][l-2][1] = Jeta[l-2];
    }
    // for the interpolation of the interior dof
    for (int p = 0; p < n_q_point[2]; ++p){
        double xp = QPoint[p][0], yp = QPoint[p][1], zp = QPoint[p][2];
        double xi = 2*xp/(1-yp-zp)-1, eta = 2*yp/(1-zp)-1, zeta = 2*zp-1;
        double Jxi[M-1], Jeta[M], Jzeta[M];
        Jxi[0] = Jeta[0] = Jzeta[0] = 1;
        Jxi[1] = calc_generalized_jacobi_polynomial(1, 1, 1, xi);
        for (int l = 1; l < M-2; ++l) // l1 = 2: M -> l1-2 = 0: M-2
            Jxi[l+1] = ((xi - calc_coefficient_a(1,1,2,l)) * Jxi[l] - calc_coefficient_a(1,1,3,l) * Jxi[l-1]) / calc_coefficient_a(1,1,1,l);
        for (int l1 = 2; l1 <= M; ++l1){
            Jeta[1] = calc_generalized_jacobi_polynomial(2*l1-1, 1, 1, eta);
            for (int l = 1; l < M - l1; ++l) // in fact, we consider l2 = 1: M-l1 -> l2-1 = 0: M-l1-1, so Jeta[M-l1] is un-used
                Jeta[l+1] = ((eta - calc_coefficient_a(2*l1-1,1,2,l)) * Jeta[l] - calc_coefficient_a(2*l1-1,1,3,l) * Jeta[l-1]) / calc_coefficient_a(2*l1-1,1,1,l);
            for (int l2 = 1; l2 <= M - l1; ++l2){
                int aph = 2 * l1 + 2 * l2 - 1;
                Jzeta[1] = calc_generalized_jacobi_polynomial(aph, 1, 1, zeta);
                for (int l = 1; l < M - l1 - l2; ++l) // similarly, Jzeta[M-l1-l2] is un-used
                    Jzeta[l+1] = ((zeta - calc_coefficient_a(aph,1,2,l)) * Jzeta[l] - calc_coefficient_a(aph,1,3,l) * Jzeta[l-1]) / calc_coefficient_a(aph,1,1,l);
                for (int l3 = 1; l3 <= M - l1 - l2; ++l3){
                    int ind_index = correspondence.index2number(Unitary_Multiindex[0] * (l1-2) + Unitary_Multiindex[1] * (l2-1) + Unitary_Multiindex[2] * (l3-1));
                    basis_value_interp[2][p][ind_index] = Jxi[l1-2] * Jeta[l2-1]*pow(1-eta,l1-2) * Jzeta[l3-1]*pow(1-zeta,l1+l2-3);
                }
            }
        }
    }
    std::cerr << "calculate the basis value for interpolation\n";
    
    
    // assign the weight_location, geometry_dimension and geometry_order of dof, which determine the order of these geometry in discretized matrix
    int n_geometry_total = 0;
    for (int ind = 0; ind <= DIM; ++ind)
        n_geometry_total += n_geometry[ind];
    std::vector<double> weight_location(n_geometry_total); // the weight_location of 0: 3 dimensional geometry in turns
    std::vector<int> geometry_dimension(n_geometry_total);
    std::vector<int> geometry_order(n_geometry_total); // [i = 0:n_geometry_total-1] the order of i-th entry in weight_location, whose dimension is geometry_dimension[i]
    // correspondence between fem dof/element and geometry
    std::vector<int> transform_femdof2geometry(n_dof, -1); // index from fem dof to 0 & 1 dimensional geometry, for 1 dimensional geometry, its index plus mesh.n_geometry(0)
    std::vector<std::vector<double> > transform_femele2geometry(n_element); // [i][ind = 0:4] index of geometry in i-th fem element, ind = 0:3 correspond to face (in front of ind-th vertex), ind = 4 for tetrahedron
    for (int i = 0; i < n_element; ++i)
        transform_femele2geometry[i].resize(5);
    std::vector<int> location_geometry(n_geometry_total); // location of all geometry (0:3 dimensional) according to increasing order of weight_location
    std::vector<int> location_actualdof(n_geometry_total); // start index of geometry in actual discretized matrix
    /*
     * transform_femdof2geometry (0 & 1 dimensional geometry) -> total index = 0: n_geometry_total -> location_actualdof[location_geometry[total index]]
     * transform_femele2geometry (2 & 3 dimensional geometry)
     */
    for (int ind = 0; ind <= DIM; ++ind){
        int index_start = 0;
        for (int indt = 0; indt < ind; ++indt)
            index_start += n_geometry[indt];
        for (int i = 0; i < n_geometry[ind]; ++i){
            geometry_dimension[index_start + i] = ind;
            geometry_order[index_start + i] = i;
        }
    }
    // construct correspondence between fem dof and geometry (I): find weight_location for 0 & 1 dimensional geometry according to the order in fem_space
    for (int i = 0; i < n_dof; ++i)
        for (int ind = 0; ind <= 1 && transform_femdof2geometry[i] < 0; ++ind) // as all order in fem_space is natural number, so >= 0
            for (int j = 0; j < n_geometry[ind]; ++j)
                if (distance(point_ref_mesh[ind][j], fem_space.dofInfo(i).interp_point) < 1.0e-8){
                    transform_femdof2geometry[i] = ind * n_geometry[0] + j; // if ind == 1, add n_geometry[0], total index of point or edge
                    weight_location[transform_femdof2geometry[i]] = i;
                    break;
                }
    // calculate weight_location for 2 & 3 dimensional geometry
    for (int ind = 2; ind <= DIM; ++ind){
        int index_start = n_geometry[0] + n_geometry[1] + (ind-2) * n_geometry[2]; // if ind == 3, add n_geometry[2]
        for (int i = 0; i < n_geometry[ind]; ++i){
            double weight_tmp = 0.0;
            for (int indt = 0; indt <= ind; ++indt)
                weight_tmp += weight_location[mesh.geometry(ind, i).vertex(indt)];
            weight_tmp /= (ind + 1.0);
            weight_location[index_start + i] = weight_tmp;
        }
    }
    // sort according to weight_location
    for (int i = 1; i < n_geometry_total; ++i)
        for (int j = i; j > 0; --j)
            if (weight_location[j] < weight_location[j-1]){
                double tmp = weight_location[j];
                weight_location[j] = weight_location[j-1];
                weight_location[j-1] = tmp;
                int tmpi = geometry_dimension[j];
                geometry_dimension[j] = geometry_dimension[j-1];
                geometry_dimension[j-1] = tmpi;
                tmpi = geometry_order[j];
                geometry_order[j] = geometry_order[j-1];
                geometry_order[j-1] = tmpi;
            }
    for (int i = 1; i < n_geometry_total; ++i)
        if (weight_location[i] < weight_location[i-1])
            std::cout << "error in sort of weight_location\n";
    for (int i = 0; i < n_geometry_total; ++i){ // assign location for geometry_order[i]-th geometry_dimension[i] dimensional geometry
        int index = geometry_order[i]; // recover the index of geometry in whole order
        for (int ind = 0; ind < geometry_dimension[i]; ++ind)
            index += n_geometry[ind];
        location_geometry[index] = i;
    }
    // insert dof into each location_geometry
    location_actualdof[0] = 0;
    for (int i = 1; i < n_geometry_total; ++i)
        location_actualdof[i] = location_actualdof[i-1] + n_dof_geometry[geometry_dimension[i-1]];
    // construct correspondence between fem element and geometry (II), traverse fem element, find location for 2 & 3 dimensional geometry of fem element
    the_element = fem_space.beginElement();
    for (int i = 0; the_element != end_element; ++the_element, ++i){
        const std::vector<int>& element_dof = the_element->dof();
        AFEPack::Point<DIM> point_tmp;
        for (int j = 0; j < 4; ++j) // the summation of all points
            point_tmp += fem_space.dofInfo(element_dof[j]).interp_point;
        AFEPack::Point<DIM> point_now = point_tmp;
        point_now *= 0.25;
        int start_tetrahedron = n_geometry[0] + n_geometry[1] + n_geometry[2];
        for (int j = 0; j < n_geometry[3]; ++j)
            if (distance(point_now, point_ref_mesh[3][j]) < 1.0e-8){
                transform_femele2geometry[i][4] = start_tetrahedron + j; // total index of tetrahedron
                break;
            }
        int start_triangle = n_geometry[0] + n_geometry[1];
        for (int ind = 0; ind < 4; ++ind){
            point_now = point_tmp;
            point_now -= fem_space.dofInfo(element_dof[ind]).interp_point;
            point_now /= 3.0;
            for (int j = 0; j < n_geometry[2]; ++j)
                if (distance(point_now, point_ref_mesh[2][j]) < 1.0e-8){
                    transform_femele2geometry[i][ind] = start_triangle + j; // total index of triangle
                    break;
                }
        }
    }

    // construct index for dof in each fem element
    std::vector<std::vector<double> > transform_fem2dof(n_element);
    for (int i = 0; i < n_element; ++i)
        transform_fem2dof[i].resize(n_index);
    the_element = fem_space.beginElement();
    for (int i = 0; the_element != end_element; ++the_element, ++i){
        const std::vector<int>& element_dof = the_element->dof();
        // point index, (0, 0, 0) and Unitary_Multiindex[0:2]
        for (int j = 0; j <= 3; ++j)
            transform_fem2dof[i][j] = location_actualdof[location_geometry[transform_femdof2geometry[element_dof[j]]]];
        // edge index
        for (int ind = 0; ind < DIM; ++ind){
            // $E_{01}$, $E_{02}$, $E_{03}$, correspond to element_dof[4:6], respectively
            int location_start = location_actualdof[location_geometry[transform_femdof2geometry[element_dof[ind+4]]]];
            for (int l = 2; l <= M; ++l)
                transform_fem2dof[i][correspondence.index2number(Unitary_Multiindex[ind] * l)] = location_start + l - 2;
            // $E_{23}$, $E_{13}$, $E_{12}$, correspond to element_dof[7:9], respectively
            location_start = location_actualdof[location_geometry[transform_femdof2geometry[element_dof[ind+7]]]];
            int index_smaller = ((ind == 0) ? 2 : 1); // smaller nonzero index of multiindex: 23 -> 2, 13 -> 1, 12 -> 1
            for (int l = 2; l <= M; ++l){
                Multiindex index_tmp = Unitary_Multiindex[index_smaller -1] + Unitary_Multiindex[5-ind - index_smaller -1] * (l-1); // 5-ind = summation of indices of two endpoints, -1 for Unitary_Multiindex[0:2] but not 1:3
                transform_fem2dof[i][correspondence.index2number(index_tmp)] = location_start + l - 2;
            }
        }
        // face index
        for (int ind = 0; ind <= 3; ++ind){
            int location_start = location_actualdof[location_geometry[transform_femele2geometry[i][ind]]];
            for (int l1 = 2; l1 <= M; ++l1)
                for (int l2 = 1; l2 <= M-l1; ++l2){
                    int order = (1+l1+l2-3)*(l1+l2-3)/2 + l2-1; // order of multiindex (l1, l2) with l1 >= 2, l2 >= 1, which is equivalent to the lexicographical order of (l1-2, l2-1)
                    Multiindex index_tmp;
                    if (ind == 0)
                        index_tmp = Unitary_Multiindex[0] + Unitary_Multiindex[1] * (l1-1) + Unitary_Multiindex[2] * l2;
                    else{
                        int index_smaller = ((ind == 1) ? 2 : 1); // smaller location nonzero index of multiindex
                        int index_larger  = ((ind == 3) ? 2 : 3); // larger location nonzero index of multiindex
                        index_tmp = Unitary_Multiindex[index_smaller-1] * l1 + Unitary_Multiindex[index_larger-1] * l2;
                    }
                    transform_fem2dof[i][correspondence.index2number(index_tmp)] = location_start + order;
                }
        }
        // tetrahedron index
        int location_start_tetrahedron = location_actualdof[location_geometry[transform_femele2geometry[i][4]]];
        for (int l1 = 2; l1 <= M; ++l1)
            for (int l2 = 1; l2 <= M; ++l2)
                for (int l3 = 1; l3 <= M; ++l3){
                    if (l1 + l2 + l3 > M) continue;
                    Multiindex index_tmp = Unitary_Multiindex[0] * l1 + Unitary_Multiindex[1] * l2 + Unitary_Multiindex[2] * l3;
                    int order = correspondence.index2number(index_tmp - Unitary_Multiindex[0] * 2 - Unitary_Multiindex[1] - Unitary_Multiindex[2]);
                    transform_fem2dof[i][correspondence.index2number(index_tmp)] = location_start_tetrahedron + order;
                }
    }
    
    // construct tranform_local, weight_transform_local: generalize jacobi polynomial -> basis function
    int n_transform_local[n_index];
    std::vector<std::vector<int> > transform_local(n_index);
    std::vector<std::vector<double> > weight_transform_local(n_index);
    // vertex modes
    n_transform_local[0] = 4; n_transform_local[1] = 2; n_transform_local[2] = 3; n_transform_local[3] = 4;
    for (int ind = 0; ind <= 3; ++ind){
        transform_local[ind].resize(n_transform_local[ind]);
        weight_transform_local[ind].resize(n_transform_local[ind]);
    }
    transform_local[0][0] = 0; weight_transform_local[0][0] = 0.125; // $J_{0,0,0} -> \varphi_{0,0,0}$
    transform_local[0][1] = 1; weight_transform_local[0][1] = 0.125; // $J_{0,0,0} -> \varphi_{1,0,0}$
    transform_local[0][2] = 2; weight_transform_local[0][2] = 0.25;  // $J_{0,0,0} -> \varphi_{0,1,0}$
    transform_local[0][3] = 3; weight_transform_local[0][3] = 0.5;   // $J_{0,0,0} -> \varphi_{0,0,1}$
    transform_local[1][0] = 0; weight_transform_local[1][0] = -0.5;  // $J_{1,0,0} -> \varphi_{0,0,0}$
    transform_local[1][1] = 1; weight_transform_local[1][1] = 0.5;   // $J_{1,0,0} -> \varphi_{1,0,0}$
    transform_local[2][0] = 0; weight_transform_local[2][0] = -0.25; // $J_{0,1,0} -> \varphi_{0,0,0}$
    transform_local[2][1] = 1; weight_transform_local[2][1] = -0.25; // $J_{0,1,0} -> \varphi_{1,0,0}$
    transform_local[2][2] = 2; weight_transform_local[2][2] = 0.5;   // $J_{1,1,0} -> \varphi_{0,1,0}$
    transform_local[3][0] = 0; weight_transform_local[3][0] = -0.125;// $J_{0,0,1} -> \varphi_{0,0,0}$
    transform_local[3][1] = 1; weight_transform_local[3][1] = -0.125;// $J_{0,0,1} -> \varphi_{1,0,0}$
    transform_local[3][2] = 2; weight_transform_local[3][2] = -0.25; // $J_{0,0,1} -> \varphi_{0,1,0}$
    transform_local[3][3] = 3; weight_transform_local[3][3] = 0.5;   // $J_{0,0,1} -> \varphi_{0,0,1}$
    // edge modes
    for (int l = 2; l <= M; ++l){
        // $J_{l,0,0}$ -> $\varphi_{l,0,0}$ 
        Multiindex index_tmp3 = Unitary_Multiindex[0] * l;
        int ind_tmp3 = correspondence.index2number(index_tmp3);
        n_transform_local[ind_tmp3] = 1;
        transform_local[ind_tmp3].resize(n_transform_local[ind_tmp3]);
        weight_transform_local[ind_tmp3].resize(n_transform_local[ind_tmp3]);
        transform_local[ind_tmp3][0] = ind_tmp3; weight_transform_local[ind_tmp3][0] = 2;
        // $J_{0,l,0}$, $J_{1,l-1,0}$ -> $\varphi_{0,l,0}$, $\varphi_{1,l-1,0}$
        Multiindex index_tmp1 = Unitary_Multiindex[1] * l;
        Multiindex index_tmp2 = Unitary_Multiindex[0] + Unitary_Multiindex[1] * (l-1);
        int ind_tmp1 = correspondence.index2number(index_tmp1);
        int ind_tmp2 = correspondence.index2number(index_tmp2);
        n_transform_local[ind_tmp1] = 2;
        n_transform_local[ind_tmp2] = 2;
        transform_local[ind_tmp1].resize(n_transform_local[ind_tmp1]);
        transform_local[ind_tmp2].resize(n_transform_local[ind_tmp2]);
        weight_transform_local[ind_tmp1].resize(n_transform_local[ind_tmp1]);
        weight_transform_local[ind_tmp2].resize(n_transform_local[ind_tmp2]);
        transform_local[ind_tmp1][0] = ind_tmp1; weight_transform_local[ind_tmp1][0] = 1;         // $J_{0,l,0}$   -> $\varphi_{0,l,0}$
        transform_local[ind_tmp1][1] = ind_tmp2; weight_transform_local[ind_tmp1][1] = 1;         // $J_{0,l,0}$   -> $\varphi_{1,l-1,0}$
        transform_local[ind_tmp2][0] = ind_tmp1; weight_transform_local[ind_tmp2][0] = (l-1.0)/l; // $J_{1,l-1,0}$ -> $\varphi_{0,l,0}$
        transform_local[ind_tmp2][1] = ind_tmp2; weight_transform_local[ind_tmp2][1] =-(l-1.0)/l; // $J_{1,l-1,0}$ -> $\varphi_{1,l-1,0}$
        // $J_{0,0,l}$, $J_{1,0,l-1}$, $J_{0,1,l-1}$ -> $\varphi_{0,0,l}$, $varphi_{1,0,l-1}$, $varphi_{0,1,l-1}$
        index_tmp1 = Unitary_Multiindex[2] * l;
        index_tmp2 = Unitary_Multiindex[0] + Unitary_Multiindex[2] * (l-1);
        index_tmp3 = Unitary_Multiindex[1] + Unitary_Multiindex[2] * (l-1);
        ind_tmp1 = correspondence.index2number(index_tmp1);
        ind_tmp2 = correspondence.index2number(index_tmp2);
        ind_tmp3 = correspondence.index2number(index_tmp3);
        n_transform_local[ind_tmp1] = 3;
        n_transform_local[ind_tmp2] = 2;
        n_transform_local[ind_tmp3] = 3;
        transform_local[ind_tmp1].resize(n_transform_local[ind_tmp1]);
        transform_local[ind_tmp2].resize(n_transform_local[ind_tmp2]);
        transform_local[ind_tmp3].resize(n_transform_local[ind_tmp3]);
        weight_transform_local[ind_tmp1].resize(n_transform_local[ind_tmp1]);
        weight_transform_local[ind_tmp2].resize(n_transform_local[ind_tmp2]);
        weight_transform_local[ind_tmp3].resize(n_transform_local[ind_tmp3]);
        transform_local[ind_tmp1][0] = ind_tmp1; weight_transform_local[ind_tmp1][0] = 0.5;           // $J_{0,0,l}$   -> $\varphi_{0,0,l}$
        transform_local[ind_tmp1][1] = ind_tmp2; weight_transform_local[ind_tmp1][1] = 0.5;           // $J_{0,0,l}$   -> $\varphi_{1,0,l-1}$
        transform_local[ind_tmp1][2] = ind_tmp3; weight_transform_local[ind_tmp1][2] = 1;             // $J_{0,0,l}$   -> $\varphi_{0,1,l-1}$
        transform_local[ind_tmp2][0] = ind_tmp1; weight_transform_local[ind_tmp2][0] = (l-1.0)/l;     // $J_{1,0,l-1}$ -> $\varphi_{0,0,l}$
        transform_local[ind_tmp2][1] = ind_tmp2; weight_transform_local[ind_tmp2][1] =-(l-1.0)/l;     // $J_{1,0,l-1}$ -> $\varphi_{1,0,l-1}$
        transform_local[ind_tmp3][0] = ind_tmp1; weight_transform_local[ind_tmp3][0] = (l-1.0)/(2*l); // $J_{0,1,l-1}$ -> $\varphi_{0,0,l}$
        transform_local[ind_tmp3][1] = ind_tmp2; weight_transform_local[ind_tmp3][1] = (l-1.0)/(2*l); // $J_{0,1,l-1}$ -> $\varphi_{1,0,l-1}$
        transform_local[ind_tmp3][2] = ind_tmp3; weight_transform_local[ind_tmp3][2] =-(l-1.0)/l;     // $J_{0,1,l-1}$ -> $\varphi_{0,1,l-1}$
    }
    // face modes
    for (int l1 = 2; l1 <= M; ++l1)
        for (int l2 = 1; l2 <= M-l1; ++l2){
            // $J_{0,l1,l2}$, $J_{1,l1-1,l2}$ -> $\varphi_{0,l1,l2}$, $varphi_{1,l1-1,l2}$
            Multiindex index_tmp1 = Unitary_Multiindex[1] * l1 + Unitary_Multiindex[2] * l2;
            Multiindex index_tmp2 = Unitary_Multiindex[0] + Unitary_Multiindex[1] * (l1-1) + Unitary_Multiindex[2] * l2;
            int ind_tmp1 = correspondence.index2number(index_tmp1);
            int ind_tmp2 = correspondence.index2number(index_tmp2);
            n_transform_local[ind_tmp1] = 2;
            n_transform_local[ind_tmp2] = 2;
            transform_local[ind_tmp1].resize(n_transform_local[ind_tmp1]);
            transform_local[ind_tmp2].resize(n_transform_local[ind_tmp2]);
            weight_transform_local[ind_tmp1].resize(n_transform_local[ind_tmp1]);
            weight_transform_local[ind_tmp2].resize(n_transform_local[ind_tmp2]);
            transform_local[ind_tmp1][0] = ind_tmp1; weight_transform_local[ind_tmp1][0] = 1;           // $J_{0,l1,l2}$   -> $\varphi_{0,l1,l2}$
            transform_local[ind_tmp1][1] = ind_tmp2; weight_transform_local[ind_tmp1][1] = 1;           // $J_{0,l1,l2}$   -> $\varphi_{1,l1-1,l2}$
            transform_local[ind_tmp2][0] = ind_tmp1; weight_transform_local[ind_tmp2][0] = (l1-1.0)/l1; // $J_{1,l1-1,l2}$ -> $\varphi_{0,l1,l2}$
            transform_local[ind_tmp2][1] = ind_tmp2; weight_transform_local[ind_tmp2][1] =-(l1-1.0)/l1; // $J_{1,l1-1,l2}$ -> $\varphi_{1,l1-1,l2}$
            // $J_{l1,0,l2}$ -> $\varphi_{l1,0,l2}$ and $J_{l1,l2,0}$ -> $\varphi_{l1,l2,0}$
            for (int ind = 1; ind <= 2; ++ind){
                Multiindex index_tmp = Unitary_Multiindex[0] * l1 + Unitary_Multiindex[ind] * l2;
                int ind_tmp = correspondence.index2number(index_tmp);
                n_transform_local[ind_tmp] = 1;
                transform_local[ind_tmp].resize(n_transform_local[ind_tmp]);
                weight_transform_local[ind_tmp].resize(n_transform_local[ind_tmp]);
                transform_local[ind_tmp][0] = ind_tmp; weight_transform_local[ind_tmp][0] = 2;
            }
        }
    // interior modes
    for (int l1 = 2; l1 <= M; ++l1)
        for (int l2 = 1; l2 <= M-l1; ++l2)
            for (int l3 = 1; l3 <= M-l1-l2; ++l3){
                Multiindex index_tmp = Unitary_Multiindex[0] * l1 + Unitary_Multiindex[1] * l2 + Unitary_Multiindex[2] * l3;
                int ind_tmp = correspondence.index2number(index_tmp);
                n_transform_local[ind_tmp] = 1;
                transform_local[ind_tmp].resize(n_transform_local[ind_tmp]);
                weight_transform_local[ind_tmp].resize(n_transform_local[ind_tmp]);
                transform_local[ind_tmp][0] = ind_tmp; weight_transform_local[ind_tmp][0] = 1;
            }
    
    // generate actual basis function value at local fem element, by transform_local and weigth_transform_local
    std::vector<std::vector<double> > basis_value_actual(n_q_point[DIM-1]); // [p = 0:n_q_point[ind]-1][]: basis_value for 3 dimensional quadrature region
    for (int p = 0; p < n_q_point[DIM-1]; ++p){
        basis_value_actual[p].resize(n_index);
        for (int i = 0; i < n_index; ++i)
            basis_value_actual[p][i] = 0;
    }
    // traverse 3-d quadrature point, use transform_local and weight_transform_local, calculate basis_value_actual
    for (int p = 0; p < n_q_point[DIM-1]; ++p)
        for (int i = 0; i < n_index; ++i)
            for (int j = 0; j < n_transform_local[i]; ++j)
                basis_value_actual[p][transform_local[i][j]] += weight_transform_local[i][j] * basis_value[DIM-1][p][i];

    
    // calculate coefficient and multiindex for the assignment of discretized matrix
    std::vector<double> n_index_variation(6); // number of the coefficient for the derivative of generalized jacobi polynomial
    std::vector<std::vector<Multiindex> > index_variation(6); // variation of multiindex corresponding to the coefficients
    std::vector<std::vector<std::vector<double> > > coefficient_derivative(6);
    // assign n_index_variation, intialize index_variation
    n_index_variation[0] = 1; // $\partial x1$,               or multiindex (2, 0, 0)
    n_index_variation[1] = 2; // $\partial x2 - \partial x1$, or multiindex (1, 1, 0)
    n_index_variation[2] = 4; // $\partial x1 - \partial x3$, or multiindex (1, 0, 1)
    n_index_variation[3] = 2; // $\partial x2$,               or multiindex (0, 2, 0)
    n_index_variation[4] = 2; // $\partial x3 - \partial x2$, or multiindex (0, 1, 1)
    n_index_variation[5] = 4; // $\partial x3$,               or multiindex (0, 0, 2)
    for (int ind = 0; ind < 6; ++ind)
        index_variation[ind].resize(n_index_variation[ind]);
    // assign index_variation respectively
    // $\partial x1$,               or multiindex (2, 0, 0)
    index_variation[0][0] = Unitary_Multiindex[0];
    // $\partial x2 - \partial x1$, or multiindex (1, 1, 0), p = 0, 1 in turns
    index_variation[1][0] = Unitary_Multiindex[1];
    index_variation[1][1] = Unitary_Multiindex[0];
    // $\partial x1 - \partial x3$, or multiindex (1, 0, 1), (p, q) = (0, 0), (1, 0), (0, 1), (1, 1) in turns
    index_variation[2][0] = Unitary_Multiindex[2];
    index_variation[2][1] = Unitary_Multiindex[0] - Unitary_Multiindex[1] + Unitary_Multiindex[2];
    index_variation[2][2] = Unitary_Multiindex[1];
    index_variation[2][3] = Unitary_Multiindex[0];
    // $\partial x2$,               or multiindex (0, 2, 0), p = 0, 1 in turns
    for (int i = 0; i < n_index_variation[3]; ++i)
        index_variation[3][i] = index_variation[1][i];
    // $\partial x3 - \partial x2$, or multiindex (0, 1, 1), q = 0, 1 in turns, correspond to (0, q) for (p, q)
    index_variation[4][0] = Unitary_Multiindex[2];
    index_variation[4][1] = Unitary_Multiindex[1];
    // $\partial x3$,               or multiindex (0, 0, 2), (p, q) = (0, 0), (1, 0), (0, 1), (1, 1) in turns
    for (int i = 0; i < n_index_variation[5]; ++i)
        index_variation[5][i] = index_variation[2][i];
    // calculate the corresponding coefficient
    for (int ind = 0; ind < 6; ++ind){
        coefficient_derivative[ind].resize(n_index_variation[ind]);
        for (int indt = 0; indt < n_index_variation[ind]; ++indt){
            coefficient_derivative[ind][indt].resize(n_index);
            for (int i = 0; i < n_index; ++i)
                if (index_variation[ind][indt] <= correspondence.number2index(i))
                    coefficient_derivative[ind][indt][i] = calc_coefficient_D(ind, indt, correspondence.number2index(i));
                else coefficient_derivative[ind][indt][i] = 0;
        }
    }

    // construct sparsity pattern for stiff matrix element
    int n_index_stiff = correspondence.n_index_end(M-1); // as the order of polynomial for stiff matrix is M - 1
    std::vector<unsigned int> n_nnz_per_row(n_index_stiff, 5 * 5 * 5); // the largest one, h^{(3,2)}
    std::vector<SparsityPattern> sp_stiff_matrix_element(6);
    Multiindex index_zero = Unitary_Multiindex[0] - Unitary_Multiindex[0]; // zero multiindex
    for (int i = 0; i < 6; ++i)
        sp_stiff_matrix_element[i].reinit(n_index_stiff, n_index_stiff, n_nnz_per_row);
    for (int row = 0; row < n_index_stiff; ++row){
        Multiindex index_now = correspondence.number2index(row);
        for (int d1 = -2; d1 <= 2; ++d1)
            for (int d2 = -2; d2 <= 2; ++d2)
                for (int d3 = -2; d3 <= 2; ++d3){
                    Multiindex index_tmp = index_now + Unitary_Multiindex[0] * d1 + Unitary_Multiindex[1] * (d2-d1) + Unitary_Multiindex[2] * (d3-d2);
                    if (!(index_zero <= index_tmp) || index_tmp.sum() >= M) continue;
                    int col = correspondence.index2number(index_tmp);
                    // the sparsity pattern of stiff matrix element (1, 1), which corresponds to multiindex (2, 0, 0)
                    if (d1 == 0 && abs(d2) <= 1)
                        sp_stiff_matrix_element[0].add(row, col);
                    // the sparsity pattern of stiff matrix element (2, 1), which corresponds to multiindex (1, 1, 0)
                    if (abs(d1) <= 1 && abs(d2) <= 1)
                        sp_stiff_matrix_element[1].add(row, col);
                    // the sparsity pattern of stiff matrix element (3, 1), which corresponds to multiindex (1, 0, 1)
                    if (abs(d1) <= 1)
                        sp_stiff_matrix_element[2].add(row, col);
                    // the sparsity pattern of stiff matrix element (2, 2), which corresponds to multiindex (0, 2, 0)
                    if (abs(d1) <= 1 && abs(d2) <= 1)
                        sp_stiff_matrix_element[3].add(row, col);
                    // the sparsity pattern of stiff matrix element (3, 2), which corresponds to multiindex (0, 1, 1)
                    sp_stiff_matrix_element[4].add(row, col);
                    // the sparsity pattern of stiff matrix element (3, 3), which corresponds to multiindex (0, 0, 2)
                    if (abs(d1) <= 1)
                        sp_stiff_matrix_element[5].add(row, col);
                }
    }
    for (int i = 0; i < 6; ++i)
        sp_stiff_matrix_element[i].compress();
    // construct sparse matrix of stiff matrix element
    std::vector<SparseMatrix<double> > stiff_matrix_element(6);
    for (int i = 0; i < 6; ++i)
        stiff_matrix_element[i].reinit(sp_stiff_matrix_element[i]);
    double C1[6]; // coefficient C1
    double C2[6]; // coefficient C2 for each choice of d1
    double C3[6]; // coefficient C3 for each choice of d1+d2a = d2
    for (int row = 0; row < n_index_stiff; ++row){
        Multiindex index_row = correspondence.number2index(row);
        int l1 = index_row.index[0], l2 = index_row.index[1], l3 = index_row.index[2];
        bool flag_exchange = false;
        for (int d1 = -2; d1 <= 2; ++d1){
            // initialize
            for (int i = 0; i < 6; ++i)
                C1[i] = 0;
            // continue if multiindex has negative component
            int k1 = l1 + d1;
            if (k1 < 0) continue;
            // corresponds to (1, 1), or multiindex (2, 0, 0)
            if (d1 == 0) C1[0] = 2.0 / (2*l1 + 1); // d1 = 0
            if (l1 == 0){
                if (0 <= d1 && d1 <= 1){
                    // corresponds to (2, 1), or multiindex (1, 1, 0)
                    C1[1] = 2 - 3 * d1; // d1 = 0: 1
                    // corresponds to (3, 1), or multiindex (1, 0, 1)
                    C1[2] = 2 - 3 * d1; // d1 = 0: 1
                    // corresponds to (2, 2), or multiindex (0, 2, 0)
                    C1[3] = 2 - d1; // d1 = 0: 1
                    // corresponds to (3, 3), or multiindex (0, 0, 2)
                    C1[5] = 2 - d1; // d1 = 0: 1
                }
                // corresponds to (3, 2), or mulltindex (0, 1, 1)
                switch (d1){ // d1 = 0: 2
                case 0: C1[4] = 2; break;
                case 2: C1[4] = -1.0/3; break;
                default: C1[4] = 0;
                }
            }
            else{
                if (abs(d1) <= 1){
                    // corresponds to (2, 1), or multiindex (1, 1, 0)
                    C1[1] = 1.0 / (2*l1) * (calc_delta(d1, 0) - calc_coefficient_a(-1, 0, d1+2, l1+d1)); // d1 = -1: 1
                    // corresponds to (3, 1), or multiindex (1, 0, 1)
                    C1[2] = 1.0 / (2*l1) * (calc_delta(d1, 0) - calc_coefficient_a(-1, 0, d1+2, l1+d1)); // d1 = -1: 1
                    // corresponds to (2, 2), or multiindex (0, 2, 0)
                    C1[3] = 1.0 / (2*l1) * (calc_delta(d1, 0) + calc_coefficient_a(0, -1, d1+2, l1+d1)); // d1 = -1: 1
                    // correspondes to (3, 3), or multiindex (0, 0, 2)
                    C1[5] = 1.0 / (2*l1) * (calc_delta(d1, 0) + calc_coefficient_a(0, -1, d1+2, l1+d1)); // d1 = -1: 1
                }
                // corresponds to (3, 2), or multiindex (0, 1, 1)
                if (l1 == 1)
                    switch (k1){
                    case 1: C1[4] = 2.0/3; break;
                    case 3: C1[4] = -2.0/15; break;
                    default: C1[4] = 0;
                    }
                else{
                    double sum = 0;
                    for (int i1 = ((d1-1 > -1) ? d1-1 : -1);
                         i1 <= ((d1+1 < 1) ? d1+1 : 1); ++i1)
                        // if (l1 + i1 >= 0)
                        sum += (calc_delta(i1, 0) + calc_coefficient_a(-1, -1, i1+2, l1+i1)) * (calc_delta(d1, i1) - calc_coefficient_a(-1, -1, d1-i1+2, l1+d1));
                    C1[4] = (l1-1.0) / ((2*l1-1)*2*l1) * sum; // d1 = -2: 2
                }
            }
            for (int d2 = -2; d2 <= 2; ++d2){
                int d2a = d2 - d1; // actual d2
                // continue if multiindex index has negative component
                int k2 = l2 + d2a;
                if (k2 < 0) continue;
                int aph2 = 2 * l1;
                for (int i = 0; i < 6; ++i) // initialize
                    C2[i] = 0;
                if (abs(d1) <= 1 && abs(d2) <= 1){
                    // corresponds to (2, 1), or multiindex (1, 1, 0)
                    C2[1] = pow(2, aph2+1) / (aph2+2*l2+1.0);
                    switch (d1){ // d2 = -1: 1
                    case -1: C2[1] *= calc_coefficient_c(aph2-2, 0, d2a+1, l2+d2a);
                        break;
                    case  0: C2[1] *= calc_delta(d2a, 0) - calc_coefficient_a(aph2, 0, d2a+2, l2+d2a);
                        break;
                    case  1: C2[1] *= 4 * calc_coefficient_g(aph2, 0, d2a+3, l2+d2a);
                    }
                    // corresponds to (2, 2), or multiindex (0, 2, 0)
                    C2[3] = C2[1];
                }
                if (l2 == 0){
                    if (d1 == 0 && 0 <= d2a && d2a <= 1)
                        // corresponds to (1, 1), or multiindex (2, 0, 0)
                        C2[0] = pow(2, aph2+2) / (aph2+2.0+d2a); // d1 = 0, d2a = 0: 1
                    if (abs(d1) <= 1 && 0 <= d2a && d2a <= 3){
                        // corresponds to (3, 1), or multiindex (1, 0, 1)
                        C2[2] = pow(2, aph2+d1+2);
                        double numerator = 1;
                        if (d2a != 0){
                            for (int i = 0; i < d2a-1; ++i)
                                numerator *= d1-1 + i;
                            numerator *= aph2 + 2*d1 + d2a;
                        }
                        double denominator = 1;
                        for (int i = 0; i < d2a+1; ++i)
                            denominator *= aph2+d1+2 + i;
                        C2[2] *= numerator / denominator; // d2a = 0: 3
                        // corresponds to (3, 3), or multiindex (0, 0, 2)
                        C2[5] = C2[2];// d2a = 0: 3
                    }
                }
                else{
                    if (d1 == 0 && abs(d2) <= 1)
                        // corresponds to (1, 1), or multiindex (2, 0, 0)
                        C2[0] = pow(2, aph2+1) * (aph2+l2+1.0) / (l2 * (aph2+2*l2+1))
                            * (calc_delta(d2a, 0) + calc_coefficient_a(aph2+1, -1, d2a+2, l2+d2a)); // d1 = 0, d2 = -1: 1
                    if (abs(d1) <= 1){
                        // corresponds to (3, 1), or multiindex (1, 0, 1)
                        C2[2] = pow(2, aph2) * (aph2+l2) / (l2 * (aph2+2.0*l2));
                        double sum = 0;
                        for (int i2 = ((d2a-1 + d1 > -1) ? d2a-1 + d1 : -1);
                             i2 <= ((d2a+1 + d1 < 1) ? d2a+1 + d1 : 1); ++i2){
                            // if (l2 + i2 < 0) continue;
                            double tmp = calc_delta(i2, 0) + calc_coefficient_a(aph2, -1, i2+2, l2+i2);
                            switch (d1){
                            case -1: sum += tmp * calc_coefficient_c(aph2-2, -1, d2a-i2+1, l2+d2a);
                                break;
                            case  0: sum += tmp * (calc_delta(d2a, i2) - calc_coefficient_a(aph2, -1, d2a-i2+2, l2+d2a));
                                break;
                            case  1: sum += tmp * 4 * calc_coefficient_g(aph2, -1, d2a-i2+3, l2+d2a);
                            }
                        }
                        C2[2] *= sum; // d1 = -1: 1, d2 = -2: 2
                        // corresponds to (3, 3), or multiindex (0, 0, 2)
                        C2[5] = C2[2]; // d1 = -1: 1, d2 = -2: 2
                    }
                }
                // corresponds to (3, 2), or multiindex (0, 1, 1)
                if (l1 == 0 && l2 == 0)
                    switch (d1){
                    case 0:
                        switch (d2a){
                        case 0: C2[4] = 2; break;
                        case 1: C2[4] = -4.0/3; break;
                        case 2: C2[4] = 1.0/3; break;
                        default: C2[4] = 0;
                        }
                        break;
                    case 1:
                        switch (d2a){
                        case 0: C2[4] = 8.0/3; break;
                        case 1: C2[4] = -2.0/3; break;
                        default: C2[4] = 0;
                        }
                        break;
                    case 2:
                        if (d2a == 0) C2[4] = 4;
                        break;
                    default: C2[4] = 0;
                    }
                else{
                    C2[4] = pow(2, aph2) / (aph2+2.0*l2);
                    double sum = 0;
                    if (d1 == -2)
                        for (int i2 = ((d2a-2 > 0) ? d2a-2 : 0);
                             i2 <= ((d2a < 2) ? d2a : 2); ++i2){
                            // if (l2 + i2 >= 0)
                            sum += calc_coefficient_c(aph2-3, 0, i2+1, l2+i2) * calc_coefficient_c(aph2-5, 0, d2a-i2+1, l2+d2a);
                        }
                    else if (d1 == 2)
                        for (int i2 = ((d2a > -2) ? d2a : -2);
                             i2 <= ((d2a+2 < 0) ? d2a+2 : 0); ++i2){
                            // if (l2 + i2 >= 0)
                            sum += 16 * calc_coefficient_g(aph2-1, 0, i2+3, l2+i2) * calc_coefficient_g(aph2+1, 0, d2a-i2+3, l2+d2a);
                        }
                    else
                        for (int i2 = ((d2a-1 + d1 > -1) ? d2a-1 + d1 : -1);
                             i2 <= ((d2a+1 + d1 < 1) ? d2a+1 + d1 : 1); ++i2){
                            // if (l2 + i2 < 0) continue;
                            double tmp = 1-abs(i2) - calc_coefficient_a(aph2-1, 0, i2+2, l2+i2);
                            switch (d1){
                            case -1: sum += tmp * calc_coefficient_c(aph2-3, 0, d2a-i2+1, l2+d2a);
                                break;
                            case  0: sum += tmp * (calc_delta(d2a, i2) - calc_coefficient_a(aph2-1, 0, d2a-i2+2, l2+d2a));
                                break;
                            case  1: sum += tmp * 4 * calc_coefficient_g(aph2-1, 0, d2a-i2+3, l2+d2a);
                            }
                        }
                    C2[4] *= sum; // d1 = -2: 2, d2 = -2: 2
                }
                // special case for (3, 2), or multiindex (0, 1, 1)
                if (l1 == 0 && k1 == 2 && l2 >= 1 && k2 == 0)
                    switch (l2){
                    case 1: C2[4] = -16.0/5;  break;
                    case 2: C2[4] = 8.0/5;    break;
                    case 3: C2[4] = -16.0/35; break;
                    case 4: C2[4] = 2.0/35;   break;
                    }
                for (int d3 = -2; d3 <= 2; ++d3){
                    int d = d1 + d2a; // d1 is exactly actual d1
                    int d3a = d3 - d; // actual d3
                    int k3 = l3 + d3a;
                    // continue if multiindex has negative component or has sum larger than M
                    Multiindex index_col = Unitary_Multiindex[0] * k1 + Unitary_Multiindex[1] * k2 + Unitary_Multiindex[2] * k3;
                    if (!(index_zero <= index_col) || index_col.sum() >= M) continue;
                    int aph3 = 2 * l1 + 2 * l2;
                    // corresponds to (3, 2), or multiindex (0, 1, 1)
                    for (int i = 0; i < 6; ++i) // initialize
                        C3[i] = 0;
                    C3[4] = pow(2, aph3+1) / (aph3+2*l3+1.0);
                    double sum = 0;
                    if (d == -2)
                        for (int i3 = ((d3a-2 > 0) ? d3a-2 : 0);
                             i3 <= ((d3a < 2) ? d3a : 2); ++i3){
                                sum += calc_coefficient_c(aph3-2, 0, i3+1, l3+i3) * calc_coefficient_c(aph3-4, 0, d3a-i3+1, l3+d3a);
                        }
                    if (d == 2)
                        for (int i3 = ((d3a > -2) ? d3a : -2);
                             i3 <= ((d3a+2 < 0) ? d3a+2 : 0); ++i3){
                                sum += 16 * calc_coefficient_g(aph3, 0, i3+3, l3+i3) * calc_coefficient_g(aph3+2, 0, d3a-i3+3, l3+d3a);
                        }
                    if (-1 <= d && d <= 1)
                        for (int i3 = ((d3a-1 + d > -1) ? d3a-1 + d : -1);
                             i3 <= ((d3a+1 + d < 1) ? d3a+1 + d : 1); ++i3){
                            double tmp = calc_delta(i3, 0) - calc_coefficient_a(aph3, 0, i3+2, l3+i3);
                            switch (d){
                            case -1: sum += tmp * calc_coefficient_c(aph3-2, 0, d3a-i3+1, l3+d3a);
                                break;
                            case  0: sum += tmp * (calc_delta(d3a, i3) - calc_coefficient_a(aph3, 0, d3a-i3+2, l3+d3a));
                                break;
                            case  1: sum += tmp * 4 * calc_coefficient_g(aph3, 0, d3a-i3+3, l3+d3a);
                            }
                        }
                    C3[4] *= sum; // d1 = -2: 2, d2 = -2: 2, d3 = -2: 2
                    if (abs(d1) <= 1){
                        // corresponds to (3, 1), or multiindex (1, 0, 1)
                        C3[2] = C3[4]; // d1 = -1: 1, d2 = -2: 2, d3 = -2: 2
                        // corresponds to (3, 3), or multiindex (0, 0, 2)
                        C3[5] = C3[4]; // d1 = -1: 1, d2 = -2: 2, d3 = -2: 2
                    }
                    if (l3 == 0){
                        if (abs(d1) <= 1 && abs(d2) <= 1 && 0 <= d3a && d3a <= 3){
                            // corresponds to (2, 1), or multiindex (1, 1, 0)
                            C3[1] = pow(2, aph3+d+3);
                            double numerator = 1;
                            if (d3a != 0){
                                for (int i = 0; i < d3a-1; ++i)
                                    numerator *= d-1 + i;
                                numerator *= aph3 + 2*d + 1 + d3a;
                            }
                            double denominator = 1;
                            for (int i = 0; i < d3a+1; ++i)
                                denominator *= aph3+d+3 + i;
                            C3[1] *= numerator / denominator; // d1 = -1: 1, d2 = -1: 1, d3a = 0: 3
                            if (d1 == 0)
                                // corresponds to (1, 1), or multiindex (2, 0, 0)
                                C3[0] = C3[1]; // d1 = 0, d2 = -1: 1, d3a = 0: 3
                            // corresponds to (2, 2), or multiindex (0, 2, 0)
                            C3[3] = C3[1]; // d1 = -1: 1, d2 = -1: 1, d3a = 0: 3
                        }
                    }
                    else{
                        if (abs(d1) <= 1 && abs(d2) <= 1){
                            // corresponds to (2, 1), or multiindex (1, 1, 0)
                            C3[1] = pow(2, aph3+1) * (aph3+l3+1.0) / (l3 * (aph3+2*l3+1));
                            sum = 0;
                            for (int i3 = ((d3a-1 + d > -1) ? d3a-1 + d : -1);
                                 i3 <= ((d3a+1 + d < 1) ? d3a+1 + d : 1); ++i3){
                                double tmp = calc_delta(i3, 0) + calc_coefficient_a(aph3+1, -1, i3+2, l3+i3);
                                switch (d){
                                case -1: sum += tmp * calc_coefficient_c(aph3-1, -1, d3a-i3+1, l3+d3a);
                                    break;
                                case  0: sum += tmp * (calc_delta(d3a, i3) - calc_coefficient_a(aph3+1, -1, d3a-i3+2, l3+d3a));
                                    break;
                                case  1: sum += tmp * 4 * calc_coefficient_g(aph3+1, -1, d3a-i3+3, l3+d3a);
                                }
                            }
                            C3[1] *= sum; // d1 = -1: 1, d2 = -1: 1, d3 = -2: 2
                            if (d1 == 0)
                                // corresponds to (1, 1), or multiindex (2, 0, 0)
                                C3[0] = C3[1]; // d1 = 0, d2 = -1: 1, d3 = -2: 2
                            // corresponds to (2, 2), or multiindex (0, 2, 0)
                            C3[3] = C3[1]; // d1 = -1: 1, d2 = -1: 1, d3 = -2: 2
                        }
                    }
                    int col = correspondence.index2number(index_col);
                    for (int i = 0; i < 6; ++i){
                        double ttmp = C1[i] * C2[i] * C3[i];
                        if (fabs(ttmp) < 1.0e-12) continue;
                        ttmp *= pow(0.5, 2*(l1+k1)+l2+k2+6);
                        stiff_matrix_element[i].add(row, col, ttmp);
                    }
                }
            }
        }
    }
    std::cerr << "generate 6 stiff matrix element\n";
    
    // construct discretized matrix
    std::vector<unsigned int> n_nonzero_per_row(n_dof_total, 0);
    the_element = fem_space.beginElement();
    for (int i = 0; the_element != end_element; ++the_element, ++i)
        for (int ind = 0; ind < 6; ++ind){
            // traverse stiff matrix element
            SparseMatrix<double>::iterator spm_ite = stiff_matrix_element[ind].begin(0);
            SparseMatrix<double>::iterator spm_end = stiff_matrix_element[ind].end(stiff_matrix_element[ind].m()-1);
            for (; spm_ite != spm_end; ++spm_ite)
                for (int ind_row_v = 0; ind_row_v < n_index_variation[ind]; ++ind_row_v)
                    for (int ind_col_v = 0; ind_col_v < n_index_variation[ind]; ++ind_col_v){
                        Multiindex index_row = correspondence.number2index(spm_ite->row())    + index_variation[ind][ind_row_v];
                        Multiindex index_col = correspondence.number2index(spm_ite->column()) + index_variation[ind][ind_col_v];
                        if (!(index_zero <= index_row) || !(index_zero <= index_col)) continue;
                        int row = correspondence.index2number(index_row);
                        int col = correspondence.index2number(index_col);
                        for (int ind_row_tl = 0; ind_row_tl < n_transform_local[row]; ++ind_row_tl)
                            for (int ind_col_tl = 0; ind_col_tl < n_transform_local[col]; ++ind_col_tl)
                                n_nonzero_per_row[transform_fem2dof[i][transform_local[row][ind_row_tl]]]++;
                    }
        }
    
    // assign location of nonzero entry
    SparsityPattern sp_stiff_matrix(n_dof_total, n_nonzero_per_row);
    the_element = fem_space.beginElement();
    for (int i = 0; the_element != end_element; ++the_element, ++i){
        for (int ind = 0; ind < 6; ++ind){
            // traverse stiff matrix element
            SparseMatrix<double>::iterator spm_ite = stiff_matrix_element[ind].begin(0);
            SparseMatrix<double>::iterator spm_end = stiff_matrix_element[ind].end(stiff_matrix_element[ind].m()-1);
            for (; spm_ite != spm_end; ++spm_ite)
                for (int ind_row_v = 0; ind_row_v < n_index_variation[ind]; ++ind_row_v)
                    for (int ind_col_v = 0; ind_col_v < n_index_variation[ind]; ++ind_col_v){
                        Multiindex index_row = correspondence.number2index(spm_ite->row())    + index_variation[ind][ind_row_v];
                        Multiindex index_col = correspondence.number2index(spm_ite->column()) + index_variation[ind][ind_col_v];
                        if (!(index_zero <= index_row) || !(index_zero <= index_col)) continue;
                        int row = correspondence.index2number(index_row);
                        int col = correspondence.index2number(index_col);
                        for (int ind_row_tl = 0; ind_row_tl < n_transform_local[row]; ++ind_row_tl)
                            for (int ind_col_tl = 0; ind_col_tl < n_transform_local[col]; ++ind_col_tl)
                                sp_stiff_matrix.add(transform_fem2dof[i][transform_local[row][ind_row_tl]],
                                                    transform_fem2dof[i][transform_local[col][ind_col_tl]]);
                    }
        }
    }
    sp_stiff_matrix.compress();
    std::cerr << "construct sparsity pattern for stiff matrix\n";
    
    // assign stiff matrix
    /*
     * stiff_matrix_element --index_variation----> stiff_matrix_element for basis function locally ( * coefficient_derivative[row & col]
     *                      --transform_local----> stiff_matrix_element for actual basis function locally ( * weight_transform_local[ind_row & ind_col]
     *                      --transform_fem2dof--> stiff_matrix ( * coef(volume) * coef_dihedral_angle
     */
    SparseMatrix<double> stiff_matrix(sp_stiff_matrix);
    Vector<double> rhs(n_dof_total);
    for (int i = 0; i < n_dof_total; ++i) rhs(i) = 0; 
    the_element = fem_space.beginElement();
    for (int i = 0; the_element != end_element; ++the_element, ++i){
        double volume = the_element->templateElement().volume();
        AFEPack::Point<DIM> point_tmp;
        for (int ind = 0; ind < DIM; ++ind) point_tmp[ind] = 1.0/3;
        double jacobian = the_element->local_to_global_jacobian(point_tmp); // the determinant of jacobian is fixed
        const std::vector<int>& element_dof = the_element->dof();
        double coef = 2.0 / (3 * fabs(volume * jacobian)); // the actual volume is fabs(volume * jacobian)
        // traverse each stiff_matrix_element, assign their contribution to stiff matrix
        for (int ind1 = 0; ind1 <= 2; ++ind1) // traverse index of face
            for (int ind2 = ind1+1; ind2 <= 3; ++ind2){
                int ind_p1, ind_p2; // endpoints of the common line between face $F_{ind1}$ and $F_{ind2}$
                if (ind1 == 0)
                    ind_p1 = ind2 % 2 + 1; // ind2 = 1: 2, 3; 2: 1, 3; 3: 1, 2
                else
                    ind_p1 = 0;
                ind_p2 = 6 - ind1 - ind2 - ind_p1;
                AFEPack::Point<DIM> p1 = fem_space.dofInfo(element_dof[ind1]).interp_point,   p2 = fem_space.dofInfo(element_dof[ind2]).interp_point;
                AFEPack::Point<DIM> ps = fem_space.dofInfo(element_dof[ind_p1]).interp_point, pe = fem_space.dofInfo(element_dof[ind_p2]).interp_point;
                double coef_dihedral_angle = 0.25 * calc_inner_product(calc_cross_product(pe - ps, p1 - ps), calc_cross_product(pe - ps, p2 - ps));
                if (fabs(coef_dihedral_angle) < 1.0e-8) continue;
                int ind = ((ind1 == 0) ? correspondence.index2number(Unitary_Multiindex[ind2-1] * 2) - 4 // corresponds to $x_{ind2}^2$, 4=correspondence.n_begin(2)
                           : correspondence.index2number(Unitary_Multiindex[ind1-1] + Unitary_Multiindex[ind2-1]) - 4); // corresponds to $x_{ind2} - x_{ind1}$
                // add contribution of stiff_matrix_element
                SparseMatrix<double>::iterator spm_ite = stiff_matrix_element[ind].begin(0);
                SparseMatrix<double>::iterator spm_end = stiff_matrix_element[ind].end(stiff_matrix_element[ind].m()-1);
                for (; spm_ite != spm_end; ++spm_ite){
                    for (int ind_row_v = 0; ind_row_v < n_index_variation[ind]; ++ind_row_v)
                        for (int ind_col_v = 0; ind_col_v < n_index_variation[ind]; ++ind_col_v){
                            Multiindex index_row = correspondence.number2index(spm_ite->row())    + index_variation[ind][ind_row_v];
                            Multiindex index_col = correspondence.number2index(spm_ite->column()) + index_variation[ind][ind_col_v];
                            if (!(index_zero <= index_row) || !(index_zero <= index_col)) continue;
                            int row = correspondence.index2number(index_row); // index of row multiindex on original(without local_transform) local stiff matrix
                            int col = correspondence.index2number(index_col);
                            for (int ind_row_tl = 0; ind_row_tl < n_transform_local[row]; ++ind_row_tl)
                                for (int ind_col_tl = 0; ind_col_tl < n_transform_local[col]; ++ind_col_tl){
                                    stiff_matrix.add(transform_fem2dof[i][transform_local[row][ind_row_tl]],
                                                     transform_fem2dof[i][transform_local[col][ind_col_tl]],
                                                     coef * coef_dihedral_angle *
                                                     coefficient_derivative[ind][ind_row_v][row] * coefficient_derivative[ind][ind_col_v][col] *
                                                     weight_transform_local[row][ind_row_tl] * weight_transform_local[col][ind_col_tl] *
                                                     spm_ite->value());
                                }
                        }
                }
            }
        // traverse 3-d quadrature point, calculate contribution of right-hand-side
        std::vector<Point<DIM> > q_point = the_element->local_to_global(QPoint);
        for (int ind_index = 0; ind_index < n_index; ++ind_index){
            double count = 0.0;
            for (int p = 0; p < n_q_point[DIM-1]; ++p)
                count += Weight[DIM-1][p] * f(q_point[p]) * basis_value_actual[p][ind_index];
            rhs(transform_fem2dof[i][ind_index]) += count * fabs(volume * jacobian);
        }
    }
    std::cerr << "construct stiff matrix and rhs\n";

    // impose boundary condition
    for (int ind = 0; ind <= 2; ++ind)
        for (int ind_geometry = 0; ind_geometry < n_geometry[ind]; ++ind_geometry){
            if (mesh.boundaryMark(ind, ind_geometry) != 1) continue;
            int location = ind_geometry + ((ind > 0) ? n_geometry[0] : 0) + ((ind > 1) ? n_geometry[1] : 0);
            int row_start = location_actualdof[location_geometry[location]];
            std::vector<double> val(n_dof_geometry[ind], 0);
            // evaluate val in the same way to interpolation
            if (ind == 0) // 0 dimensional geometry, only 1 point
                val[0] = u(mesh.point(ind_geometry));
            if (ind == 1){ // 1 dimensional geometry
                int ind_point_s = mesh.geometry(1, ind_geometry).vertex(0), ind_point_e = mesh.geometry(1, ind_geometry).vertex(1);
                int location_s = location_actualdof[location_geometry[ind_point_s]], location_e = location_actualdof[location_geometry[ind_point_e]];
                double c_s = rhs(location_s) / stiff_matrix.diag_element(location_s), c_e = rhs(location_e) / stiff_matrix.diag_element(location_e);
                for (int l = 2; l <= M; ++l){ // dof locate on this edge
                    double count = 0;
                    for (int p = 0; p < n_q_point[0]; ++p){
                        Point<DIM> p_tmp = mesh.point(ind_point_s), p_ttmp = mesh.point(ind_point_e);
                        p_tmp  *= QPoint_Barycenter[0][p][1];
                        p_ttmp *= QPoint_Barycenter[0][p][0];
                        p_tmp  += p_ttmp;
                        count += Weight[0][p] * (u(p_tmp) - c_s*QPoint_Barycenter[0][p][1] - c_e*QPoint_Barycenter[0][p][0]) * basis_value_interp[0][p][l-2];
                    }
                    val[l-2] = count * -l * (2*l - 1) / (2 * (l-1));
                }
            }
            if (ind == 2){ // 2 dimensional geometry
                for (int l1 = 2; l1 <= M; ++l1)
                    for (int l2 = 1; l2 <= M-l1; ++l2){
                        int ind_index = (1+l1+l2-3) * (l1+l2-3) / 2 + l2-1; // order of multiindex (l1-2, l2-1)
                        double count = 0;
                        for (int p = 0; p < n_q_point[1]; ++p){
                            double xp = QPoint_Barycenter[1][p][0], yp = QPoint_Barycenter[1][p][1], rp = QPoint_Barycenter[1][p][2];
                            Point<DIM> p_tmp;
                            for (int ind = 0; ind < DIM; ++ind) p_tmp[ind] = 0;
                            for (int ind_p = 0; ind_p <= 2; ++ind_p){ // vertex[0]=(0,0)<->[2]=1-x-y; vertex[1]=(1,0)<->[0]=x; vertex[2]=(0,1)<->[1]=y
                                Point<DIM> p_ttmp = mesh.point(mesh.geometry(2, ind_geometry).vertex(ind_p));
                                p_ttmp *= QPoint_Barycenter[1][p][(ind_p+2)%3];
                                p_tmp  += p_ttmp;
                            }
                            double count_p = u(p_tmp); // the contribution from function u
                            for (int ind = 0; ind < DIM; ++ind){ // substract the contribution from vertex: 0 -> 2, 1 -> 0, 2 -> 1 ((x + 2) % 3)
                                int tmp_location = location_actualdof[location_geometry[mesh.geometry(2, ind_geometry).vertex(ind)]];
                                double val_dof_vertex = rhs(tmp_location) / stiff_matrix.diag_element(tmp_location);
                                count_p -= val_dof_vertex * QPoint_Barycenter[1][p][(ind+2)%3];
                            }
                            int location_dof_edge[3]; // start location of dof on each edge
                            for (int ind_edge = 0; ind_edge < 3; ++ind_edge)
                                location_dof_edge[ind_edge] = location_actualdof[location_geometry[mesh.geometry(2, ind_geometry).boundary(ind_edge) + n_geometry[0]]];
                            for (int l = 2; l <= M; ++l){ // substract the contribution from edge
                                double val_dof_edge[3];
                                for (int i_tmp = 0; i_tmp < 3; ++i_tmp)
                                    val_dof_edge[i_tmp] = rhs(location_dof_edge[i_tmp] + l-2) / stiff_matrix.diag_element(location_dof_edge[i_tmp] + l-2);
                                count_p += 2 * (xp*yp * val_dof_edge[0] * basis_value_addition[p][l-2][1] +
                                                yp*rp * val_dof_edge[1] * basis_value_addition[p][l-2][1] +
                                                xp*rp * val_dof_edge[2] * basis_value_addition[p][l-2][0]);
                            }
                            count += Weight[1][p] * count_p * basis_value_interp[1][p][ind_index];
                        }
                        val[ind_index] = count * -l1 * (2*l1-1) * (2*l1+2*l2-1) / (pow(2, l1) * (l1-1));
                    }
            }
            // impose boundary condition to linear system
            for (int i = 0; i < n_dof_geometry[ind]; ++i){
                int row = row_start + i;
                SparseMatrix<double>::iterator spm_ite = stiff_matrix.begin(row);
                SparseMatrix<double>::iterator spm_end = stiff_matrix.end(row);
                for (; spm_ite != spm_end; ++spm_ite)
                    if (spm_ite->column() == row)
                        rhs(row) = spm_ite->value() * val[i];
                    else{
                        stiff_matrix.set(row, spm_ite->column(), 0);
                        // notice that the matrix is symmetric
                        rhs(spm_ite->column()) -= stiff_matrix.el(spm_ite->column(), row) * val[i];
                        stiff_matrix.set(spm_ite->column(), row, 0);
                    }
            }
        }
    std::cerr << "impose boundary condition\n";
    
    
    // generate precoditioner and cg solver
    PreconditionSSOR<SparseMatrix<double> > ssor;
    ssor.initialize(stiff_matrix, 1.2);
    SolverControl solver_contral(200000, 1.0e-10);
    SolverCG<Vector<double> > cg(solver_contral);
    
    Vector<double> solution(n_dof_total);
    cg.solve(stiff_matrix, solution, rhs, ssor);


    // calculate interpolation
    Vector<double> u_interp(n_dof_total);
    
    // traverse 0 dimensional geometry, correspond to vertex in fem dof
    for (int ind_point = 0; ind_point < n_geometry[0]; ++ind_point)
        u_interp(location_actualdof[location_geometry[ind_point]]) = u(mesh.point(ind_point));

    // traverse 1 dimensional geometry
    for (int ind_edge = 0; ind_edge < n_geometry[1]; ++ind_edge){
        int ind_point_s = mesh.geometry(1, ind_edge).vertex(0), ind_point_e = mesh.geometry(1, ind_edge).vertex(1);
        double c_s = u_interp(location_actualdof[location_geometry[ind_point_s]]), c_e = u_interp(location_actualdof[location_geometry[ind_point_e]]);
        for (int l = 2; l <= M; ++l){ // dof locate on this edge
            int location_dof = location_actualdof[location_geometry[ind_edge+n_geometry[0]]] + l-2; // position of this dof
            double count = 0;
            for (int p = 0; p < n_q_point[0]; ++p){
                Point<DIM> p_tmp = mesh.point(ind_point_s), p_ttmp = mesh.point(ind_point_e);
                p_tmp  *= QPoint_Barycenter[0][p][1];
                p_ttmp *= QPoint_Barycenter[0][p][0];
                p_tmp  += p_ttmp;
                count += Weight[0][p] * (u(p_tmp) - c_s*QPoint_Barycenter[0][p][1] - c_e*QPoint_Barycenter[0][p][0]) * basis_value_interp[0][p][l-2];
            }
            u_interp(location_dof) = count * -l * (2*l - 1) / (2 * (l-1));
        }
    }
    
    // traverse 2 dimensional geometry
    for (int ind_face = 0; ind_face < n_geometry[2]; ++ind_face){
        for (int l1 = 2; l1 <= M; ++l1)
            for (int l2 = 1; l2 <= M-l1; ++l2){
                int ind_index = (1+l1+l2-3) * (l1+l2-3) / 2 + l2-1; // order of multiindex (l1-2, l2-1)
                int location_dof = location_actualdof[location_geometry[ind_face+n_geometry[0]+n_geometry[1]]] + ind_index;
                double count = 0;
                for (int p = 0; p < n_q_point[1]; ++p){
                    double xp = QPoint_Barycenter[1][p][0], yp = QPoint_Barycenter[1][p][1], rp = QPoint_Barycenter[1][p][2];
                    Point<DIM> p_tmp;
                    for (int ind = 0; ind < DIM; ++ind) p_tmp[ind] = 0;
                    for (int ind_p = 0; ind_p <= 2; ++ind_p){ // vertex[0]=(0,0)<->[2]=1-x-y; vertex[1]=(1,0)<->[0]=x; vertex[2]=(0,1)<->[1]=y
                        Point<DIM> p_ttmp = mesh.point(mesh.geometry(2, ind_face).vertex(ind_p));
                        p_ttmp *= QPoint_Barycenter[1][p][(ind_p+2)%3];
                        p_tmp  += p_ttmp;
                    }
                    double count_p = u(p_tmp); // the contribution from function u
                    for (int ind = 0; ind < DIM; ++ind) // substract the contribution from vertex: 0 -> 2, 1 -> 0, 2 -> 1 ((x + 2) % 3)
                        count_p -= u_interp(location_actualdof[location_geometry[mesh.geometry(2, ind_face).vertex(ind)]]) * QPoint_Barycenter[1][p][(ind+2)%3];
                    int location_dof_edge[3]; // start location of dof on each edge
                    for (int ind_edge = 0; ind_edge < 3; ++ind_edge)
                        location_dof_edge[ind_edge] = location_actualdof[location_geometry[mesh.geometry(2, ind_face).boundary(ind_edge) + n_geometry[0]]];
                    for (int l = 2; l <= M; ++l) // substract the contribution from edge
                        count_p += 2 * (xp*yp * u_interp(location_dof_edge[0] + l-2) * basis_value_addition[p][l-2][1] +
                                        yp*rp * u_interp(location_dof_edge[1] + l-2) * basis_value_addition[p][l-2][1] +
                                        xp*rp * u_interp(location_dof_edge[2] + l-2) * basis_value_addition[p][l-2][0]);
                    count += Weight[1][p] * count_p * basis_value_interp[1][p][ind_index];
                }
                u_interp(location_dof) = count * -l1 * (2*l1-1) * (2*l1+2*l2-1) / (pow(2, l1) * (l1-1));
            }
    }
    
    // traverse fem element, assign value for interior dof
    the_element = fem_space.beginElement();
    for (int i = 0; the_element != end_element; ++the_element, ++i)
        for (int l1 = 2; l1 <= M; ++l1)
            for (int l2 = 1; l2 <= M-l1; ++l2)
                for (int l3 = 1; l3 <= M-l1-l2; ++l3){
                    int ind_index = correspondence.index2number(Unitary_Multiindex[0] * (l1-2) + Unitary_Multiindex[1] * (l2-1) + Unitary_Multiindex[2] * (l3-1));
                    int location_dof = location_actualdof[location_geometry[transform_femele2geometry[i][4]]] + ind_index;
                    double count = 0;
                    for (int p = 0; p < n_q_point[2]; ++p){
                        Point<DIM> p_tmp = the_element->local_to_global(QPoint[p]);
                        double count_p = u(p_tmp);
                        for (int j = 0; j < n_index; ++j){ // traverse multiindex for vertex, edge and face
                            Multiindex index_tmp = correspondence.number2index(j);
                            if (!(index_tmp.index[0] >= 2 && index_tmp.index[1] >= 1 && index_tmp.index[2] >= 1)) // the interior model function are orthogonal
                                count_p -= u_interp(transform_fem2dof[i][j]) * basis_value_actual[p][j];
                        }
                        count += Weight[2][p] * count_p *  basis_value_interp[2][p][ind_index];
                    }
                    u_interp(location_dof) = count * -l1 * (2*l1-1) * (2*l1+2*l2-1) * (2*l1+2*l2+2*l3-1) / (pow(2, 2*l1+l2-5) * (l1-1) * 6);
                }

    
    // calculate error
    double error_l2 = 0, error_l2_interp = 0;
    the_element = fem_space.beginElement(); 
    for (int i = 0; the_element != end_element; ++the_element, ++i){
        double volume = the_element->templateElement().volume();
        Point<DIM> point_tmp;
        for (int ind = 0; ind < DIM; ++ind) point_tmp[ind] = 1.0/3;
        double jacobian = the_element->local_to_global_jacobian(point_tmp); // the determinant of jacobian is fixed
        std::vector<Point<DIM> > q_point = the_element->local_to_global(QPoint);
        const std::vector<int>& element_dof = the_element->dof();
        double count = 0.0, count_interp = 0.0;
        for (int p = 0; p < n_q_point[DIM-1]; ++p){
            // recover the value of solution
            double val_sol = 0.0, val_sol_interp = 0.0;
            for (int ind_index = 0; ind_index < n_index; ++ind_index){
                val_sol +=        solution(transform_fem2dof[i][ind_index]) * basis_value_actual[p][ind_index];
                val_sol_interp += u_interp(transform_fem2dof[i][ind_index]) * basis_value_actual[p][ind_index];
            }
            // count the contribution
            count += Weight[DIM-1][p] * pow(val_sol - u(q_point[p]), 2);
            count_interp += Weight[DIM-1][p] * pow(val_sol_interp - u(q_point[p]), 2);
        }
        error_l2 += count * fabs(volume * jacobian);
        error_l2_interp += count_interp * fabs(volume * jacobian);
    }
    error_l2 = sqrt(error_l2);
    error_l2_interp = sqrt(error_l2_interp);
    std::cout << "the l2 error of the solution is " << std::setprecision(10) << error_l2
              << ", while the l2 error of the interpolation is " << error_l2_interp << '\n';


    // output solution with file name given by argv[3]
    std::ofstream outfile;
    outfile.open(argv[3]);
    outfile << M << '\t' << n_dof_total << '\n';
    for (int i = 0; i < n_dof_total; ++i)
	    outfile << solution(i) << '\n';
    outfile.close();
    
    return 0;
}
